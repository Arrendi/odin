## Welcome to the sausage factory!

## There are two stages to the generation:
##
## 1. first is the odin_generate1*; During this phase we build up and
##    modify an 'obj' which contains the information required to
##    generate the model.  If the model has made it through the parse
##    stage, any error there will be a odin error (hopefully).
##
## 2. second is odin_generate2*; all functions work on this object to
##    generate a character vector to put somewhere.  These are much
##    simpler generate the actual code.
odin_generate <- function(dat, package = FALSE, safe = FALSE) {
  obj <- odin_generate1(dat, safe)
  discrete <- obj$info$discrete

  struct <- c(odin_generate2_struct(obj),
              odin_generate2_support_decls(obj))
  library_fns <- odin_generate2_library_fns(obj)

  ## NOTE: For now, the interpolation functions are just slurped in
  ## here.  This should do approximately the right thing for both
  ## standalone code and for packages.  But it's not pretty.  I might
  ## move to a more formal linking (e.g., getCcallable) approach but
  ## that considerably complicates compilation and may come with a
  ## slight performance cost too.
  ##
  ## TODO: handle this the same way as the interpolation support
  ## perhaps?  Though that requires that library_fns is declared
  ## before the struct (that's not a huge headache though).
  if (discrete && obj$info$has_delay) {
    ring <- odin_ring_support(package)
  } else {
    ring <- NULL
  }

  ## Then attempt to make some sense out of the things that we have
  ## collected:
  ##
  ## NOTE: if onefile is TRUE then there's no need to include the
  ## interpolation types or the function declarations (and in fact we
  ## don't probably *want* to do that?)
  ret <- list(if (!package) odin_header(),
              if (!package) odin_version_header(dat$hash$inputs),
              if (!package) odin_includes(),
              if (!package) ring$declarations,
              if (!package) struct,
              if (!package) library_fns$declarations,
              odin_generate2_create(obj),
              odin_generate2_user(obj),
              odin_generate2_finalize(obj),
              odin_generate2_initial(obj),
              odin_generate2_set_initial(obj),
              odin_generate2_deriv(obj),
              if (!discrete) odin_generate2_output(obj),
              if (!discrete) odin_generate2_deriv_desolve(obj),
              if (!discrete) odin_generate2_deriv_dde(obj),
              if ( discrete) odin_generate2_update_dde(obj),
              odin_generate2_deriv_r(obj),
              odin_generate2_contents(obj),
              odin_generate2_order(obj),
              odin_generate2_order(obj, TRUE),
              odin_generate2_interpolate_t(obj),
              odin_generate2_support_defns(obj),
              if (!package) ring$definitions,
              if (!package) library_fns$definitions)

  ret <- ret[lengths(ret) > 0]

  txt <- paste(vcapply(ret, paste, collapse = "\n"),
               collapse = "\n\n")

  if (package) {
    list(struct = struct, code = txt, library_fns = library_fns,
         info = obj$info)
  } else {
    txt
  }
}

odin_header <- function() {
 c("// This file was automatically generated by odin.",
   "// Do not edit by hand as changes will be lost.")
}

odin_version_header <- function(hash) {
  c("// versions:",
    sprintf("// hash: %s", hash),
    sprintf("// %s: %s",
            names(ODIN_VERSION),
            vcapply(ODIN_VERSION, as.character)))
}

odin_includes <- function() {
  c("#include <R.h>",
    "#include <Rmath.h>",
    "#include <Rinternals.h>",
    "#include <R_ext/Rdynload.h>",
    "#include <stdbool.h>")
}

odin_ring_support <- function(package) {
  ## Annoyingly different from the version used in interpolate
  filter_includes <- function(filename) {
    x <- readLines(filename)
    x[!grepl("^#include\\s+", x, perl = TRUE)]
  }

  r_h <- system.file("include/ring/ring.h", package = "ring", mustWork = TRUE)
  r_c <- system.file("include/ring/ring.c", package = "ring", mustWork = TRUE)
  if (package) {
    decl <- filter_includes(r_h)
    defn <- filter_includes(r_c)
  } else {
    decl <- sprintf('#include "%s"', r_h)
    defn <- sprintf('#include "%s"', r_c)
  }
  list(declarations = decl, definitions = defn)
}

## Read a bunch of library functions.  The format here is important.
##
## This could be relaxed soon, though doing it correctly will require
## things like a proper C parser.  A more sensible route forward would
## be to allow, in addition, arbitrary functions to be listed with the
## inclusion of a header file.
read_user_c <- function(filename) {
  d <- readLines(filename)

  re1 <- "^[[:alnum:]_*]+ ([[:alnum:]_]+)(.+)"
  i1 <- grep(re1, d)
  i2 <- grep("^}$", d)
  if (length(i1) != length(i2)) {
    stop("Parse error for ", filename)
  }
  name <- sub(re1, "\\1", d[i1])
  defn <- setNames(vcapply(seq_along(i1), function(k)
    paste(d[i1[[k]]:i2[[k]]], collapse = "\n")), name)
  decl <- sub("^([^{]*?)\\s*\\{.*", "\\1;", defn)

  list(declarations = decl, definitions = defn, filename = filename)
}
