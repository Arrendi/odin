## Welcome to the sausage factory!

## TODO: better name for 'output_tmp'.  Not sure what that corresponds
## to, really.  Looks like it's some sort of "output info" or
## something...

odin_generate <- function(dat, dest=tempdir()) {
  obj <- odin_generate_loop(dat)
  ## This one is special because it fills up declarations; it miust be
  ## run first.
  support <- odin_generate_support(obj)
  library_fns <- odin_generate_library_fns(obj)
  declarations <- c(obj$declarations$get(), library_fns$declarations)

  ## TODO: The dynload one is needed only if there are delays, I
  ## believe.
  header <- c("// This file was automatically generated by odin.",
              "// Do not edit by hand as changes will be lost.",
              "#include <R.h>",
              "#include <Rinternals.h>",
              "#include <R_ext/Rdynload.h>")

  ## Then attempt to make some sense out of the things that we have
  ## collected:
  ret <- list(header,
              odin_generate_struct(obj),
              declarations,
              odin_generate_create(obj),
              odin_generate_user(obj),
              odin_generate_finalize(obj),
              odin_generate_initial(obj),
              odin_generate_deriv(obj),
              odin_generate_deriv_r(obj),
              odin_generate_contents(obj),
              odin_generate_order(obj),
              odin_generate_output_order(obj),
              odin_generate_output(obj),
              odin_generate_desolve(obj),
              odin_generate_dde(obj),
              odin_generate_info(obj),
              support,
              library_fns$definitions)

  txt <- paste(vcapply(ret, paste, collapse="\n"),
               collapse="\n\n")

  if (is.null(dest)) {
    ## Here we'll return the actual contents:
    txt
  } else {
    if (is_directory(dest) || !grepl(".", basename(dest), fixed=TRUE)) {
      dest <- file.path(dest, sprintf("%s.c", obj$base))
    }
    writeLines(txt, dest)
    dest
  }
}

## What we are going to write here is a little bit of (fairly nasty)
## reference-style code that will help generate the interface.  The
## simplest way of doing this might be to generate a small list of
## types that we can reference everywhere.  But that might just be
## more complicated than it needs to be?
odin_generate_object <- function(dat) {
  base <- dat[["config"]][["base"]]
  self <- list(base=base)

  self$info <- list(base=base,
                    has_delay=dat$has_delay,
                    has_output=dat$has_output,
                    user=dat$user,
                    initial_stage=dat$initial_stage,
                    dim_stage=dat$dim_stage)

  self$name_pars <- sprintf("%s_p", base)
  self$type_pars <- sprintf("%s_pars", base)

  ## This is the set of variables we know to be *ours*.
  lookup <- collector()

  ## Type information will generate a bunch of extra things, so
  ## process that later for simplicity:
  self$types <- collector_list()

  ## The major stages:
  self$constant <- collector_named()
  self$user <- collector_named()
  self$time <- collector_named(TRUE)
  self$output <- collector_named(TRUE)

  self$initial <- collector()
  self$free <- collector()

  ## Keep track of which library functions we need.  I'll keep those
  ## elsewhere and select them based on name.
  self$library_fns <- collector()
  self$declarations <- collector()

  self$add_element <- function(name, type, array=0) {
    if (array > 0L) {
      name_dim <- array_dim_name(name, use=FALSE)
      if (!is.null(name_dim)) {
        Recall(name_dim, "int", FALSE)
        if (array > 1L) {
          for (i in seq_len(array)) {
            Recall(array_dim_name(name, i, use=FALSE), "int")
          }
          if (array == 3L) {
            Recall(array_dim_name(name, "12", use=FALSE), "int")
          }
        }
      }
    }
    self$types$add(list(name=name, type=type, array=array))
    lookup$add(name)
  }

  ## Rewrite based on that.
  custom <- names(dat$config$include$declarations)
  self$rewrite <- function(x) {
    rewrite_c(x, self$name_pars, lookup$get(), INDEX, custom)
  }

  self
}

## TODO: Disallow '<base>_' as a name; otherwise potential for
## collision, so probably set that in the DSL rather than here.
odin_generate_loop <- function(dat) {
  obj <- odin_generate_object(dat)

  obj$add_element("odin_use_dde", "int")

  ## Set up initial time so we can refer to it later.  Not all models
  ## make use of this, but it seems worth adding (and doesn't take
  ## that much space).  Delay models will make extensive use of this.
  ## We could omit this for any non-delay model perhaps?
  ##
  ## TODO: support general RHS rewriting of initial(x) -> initial_x
  ## combined with parse-time checking of valid x.
  obj$add_element(sprintf("initial_%s", TIME), "double")

  obj$library_fns$add("get_ds_pars")
  fns <- unique(unlist(lapply(dat$eqs, function(x) x$depends$functions)))
  if ("sum" %in% fns) {
    ## TODO: We should be more clever here, but not done yet and the
    ## cost of this is low.
    obj$library_fns$add("odin_sum1")
    obj$library_fns$add("odin_sum2")
    obj$library_fns$add("odin_sum3")
  }
  if (dat$has_delay) {
    obj$library_fns$add("lagvalue_dde")
    obj$library_fns$add("lagvalue_ds")
  }

  obj$custom <- dat$config$include

  ## Need to do this out here, rather than in the main loop because
  ## otherwise when there is more than one delay variable they would
  ## be added multiple times!
  if (length(dat$delay_arrays) > 0L) {
    for (nm in dat$delay_arrays) {
      obj$add_element(nm, "double", 1L)
    }
  }

  nms <- names(dat$eqs)
  for (x in dat$eqs) {
    if (identical(x$lhs$special, "dim")) {
      odin_generate_dim(x, obj, dat)
    } else if (isTRUE(x$rhs$delay)) {
      odin_generate_delay(x, obj, dat)
    } else if (x$lhs$type == "symbol") {
      odin_generate_symbol(x, obj, dat)
    } else if (x$lhs$type == "array") {
      odin_generate_array(x, obj, dat)
    } else {
      stop("Unhandled type")
    }
  }

  initial_t_deps <- dat$initial_t_deps
  if (length(initial_t_deps)) {
    ## All of the elements here are _time_ dependent, which changes
    ## things a little.
    initial_deps <- collector()

    for (x in dat$eqs[initial_t_deps]) {
      if (identical(x$lhs$special, "dim")) {
        stop("dim use in initial should never happen (bug?)")
      } else if (isTRUE(x$rhs$delay)) {
        ## This one should be pretty easy as by definition we can't
        ## have accumulated any delays yet.  So we should be using the
        ## non-delay branch which is the easier branch.
        stop("delay use in initial not handled")
      } else if (x$lhs$type == "symbol") {
        odin_generate_symbol(x, obj, dat, initial_deps)
      } else if (x$lhs$type == "array") {
        initial_deps$add(odin_generate_array_expr(x, obj))
      } else {
        stop("Unhandled type")
      }
    }
    ## NOTE: This is a bit ugly, but I really need to process things
    ## in this order, and that is most simply dealt with by a prepend
    ## here.
    obj$initial$prepend(initial_deps$get())
  }

  if (dat$variable_order$total_is_var) {
    obj$add_element(dat$variable_order$total_use, "int")
    st <- STAGES[[dat$variable_order$total_stage]]
    obj[[st]]$add("%s = %s;",
                  obj$rewrite(dat$variable_order$total_use),
                  obj$rewrite(dat$variable_order$total))
  }
  obj$variable_size <- obj$rewrite(dat$variable_order$total_use)

  if (dat$has_output) {
    if (dat$output_order$total_is_var) {
      obj$add_element(dat$output_order$total_use, "int")
      st <- STAGES[[dat$output_order$total_stage]]
      obj[[st]]$add("%s = %s;",
                    obj$rewrite(dat$output_order$total_use),
                    obj$rewrite(dat$output_order$total))
    }
    obj$output_size <- obj$rewrite(dat$output_order$total_use)
  }

  ## We're going to use this in a couple of places and it's kind of
  ## awkward.  In contrast with vars, which is known on entry to this
  ## function, types is collected by this function so needs to be
  ## written out at the end.
  obj$types <- do.call(rbind,
                       lapply(obj$types$get(),
                              as.data.frame, stringsAsFactors=FALSE))

  vars_len <- rep_len("1", length(dat$variable_order$is_array))
  vars_len[dat$variable_order$is_array] <-
    vcapply(dat$variable_order$order[dat$variable_order$is_array],
            array_dim_name)
  obj$vars <- data.frame(
    name=dat$variable_order$order,
    is_array=dat$variable_order$is_array,
    array=dat$variable_order$array,
    used=dat$variable_order$used,
    offset=vcapply(dat$variable_order$offset_use, obj$rewrite),
    length=vcapply(vars_len, obj$rewrite),
    stringsAsFactors=FALSE)

  if (dat$has_output) {
    obj$vars$used_output <- obj$vars$name %in% dat$output_info$used
    output_len <- rep_len("1", length(dat$output_order$is_array))
    output_len[dat$output_order$is_array] <-
      vcapply(dat$output_order$order[dat$output_order$is_array],
              array_dim_name)
    obj$output_tmp <- data.frame(
      name=dat$output_order$order,
      array=dat$output_order$is_array,
      offset=vcapply(dat$output_order$offset_use, obj$rewrite),
      length=vcapply(output_len, obj$rewrite),
      stringsAsFactors=FALSE)
    ## This is a bit shit, but should do for now.
    ## TODO: filter this by stage time, though this is effectively done later.
    obj$output_exprs <- setdiff(dat$output_info$used,
                                c(obj$vars$name, rownames(obj$output_tmp)))

    if (any(obj$output_tmp$array)) {
      obj$output$add("double *output_%s = %s + %s;",
                     obj$output_tmp$name[obj$output_tmp$array], OUTPUT,
                     obj$output_tmp$offset[obj$output_tmp$array])
    }
  }

  obj
}

odin_generate_dim <- function(x, obj, dat) {
  nm <- x$name
  nm_t <- x$lhs$name_target
  is_var <- nm_t %in% dat$vars
  nm_s <- if (is_var) paste0("initial_", nm_t) else nm_t
  st <- STAGES[[x$stage]]

  obj$add_element(nm_s, "double", x$nd)
  if (x$stage == STAGE_USER) {
    obj[["constant"]]$add("%s = NULL;", obj$rewrite(nm_s))
    obj[["user"]]$add("Free(%s);", obj$rewrite(nm_s))
  } else if (x$stage > STAGE_USER) {
    stop("This should never happen!")
  }

  if (x$nd > 1L) {
    obj$library_fns$add(sprintf("odin_set_dim%d", x$nd))
  }

  if (isTRUE(x$rhs$user)) {
    ## Here, we'll need to a little extra work; get the value, check
    ## length, copy out integers.
    fn <- sprintf("get_user_array_dim%d", x$nd)
    obj$library_fns$add(fn)
    ## We really need to do this in a scoped block I think as we need
    ## to set a few things all at once.
    obj[[st]]$add("{")

    if (x$nd > 1L) {
      nm_i <- vcapply(seq_len(x$nd),
                      function(i) obj$rewrite(array_dim_name(nm_t, i)))
    } else {
      nm_i <- obj$rewrite(nm)
    }

    ## TODO "tmp" -> STATE?
    obj[[st]]$add('  double* tmp = %s(%s, "%s", %s);',
                  fn, USER, nm_s, paste0("&", nm_i, collapse=", "))
    ## TODO: This duplicates the code below for computing compound
    ## dimensions, but until I get test cases in that's probably the
    ## simplest for now (note it differs in indent though).
    if (x$nd > 1L) {
      if (x$nd == 3L) {
        obj[[st]]$add("  %s = %s;",
                      obj$rewrite(array_dim_name(nm_t, "12")),
                      paste(nm_i[1:2], collapse=" * "))
      }
      obj[[st]]$add("  %s = %s;", obj$rewrite(nm), paste(nm_i, collapse=" * "))
    }
    obj[[st]]$add("  %s = (double*) Calloc(%s, double);",
                  obj$rewrite(nm_s), obj$rewrite(nm))
    obj[[st]]$add("  memcpy(%s, tmp, %s * sizeof(double));",
                  obj$rewrite(nm_s), obj$rewrite(nm))
    obj[[st]]$add("}")
  } else {
    if (x$nd > 1L) {
      size <- as.list(x$rhs$value[-1L])
      nm_i <- vcapply(seq_len(x$nd),
                      function(i) obj$rewrite(array_dim_name(nm_t, i)))
      for (i in seq_len(x$nd)) {
        obj[[st]]$add("%s = %s;", nm_i[[i]], obj$rewrite(size[[i]]))
      }
      ## Little extra work for the 3d case.  If we were allowing
      ## arbitrary matrices here this would be heaps more complicated
      ## but we only need the special case here.
      if (x$nd == 3L) {
        obj[[st]]$add("%s = %s;",
                      obj$rewrite(array_dim_name(nm_t, "12")),
                      paste(nm_i[1:2], collapse=" * "))
      }
      obj[[st]]$add("%s = %s;", obj$rewrite(nm), paste(nm_i, collapse=" * "))
    } else {
      obj[[st]]$add("%s = %s;", obj$rewrite(nm), obj$rewrite(x$rhs$value))
    }
    obj[[st]]$add("%s = (double*) Calloc(%s, double);",
                  obj$rewrite(nm_s), obj$rewrite(nm))
  }

  obj$free$add("Free(%s);", obj$rewrite(nm_s))

  if (is_var) {
    nm_offset <- paste0("offset_", nm_t)
    obj$add_element(nm_offset, "int")
    obj[[st]]$add("%s = %s;", obj$rewrite(nm_offset),
                  obj$rewrite(dat$variable_order$offset[[nm_t]]))
  }
}

odin_generate_symbol <- function(x, obj, dat, target=NULL) {
  nm <- x$name
  type <- if (nm %in% dat$index_vars) "int" else "double"
  is_initial <- identical(x$lhs$special, "initial")
  if (is.null(target)) {
    target <- obj[[if (is_initial) "initial" else STAGES[[x$stage]]]]
    if (x$stage < STAGE_TIME || is_initial) {
      obj$add_element(nm, type)
    }
  }

  if (isTRUE(x$rhs$user)) {
    if (isTRUE(x$rhs$default)) {
      default <- obj$rewrite(x$rhs$value)
    } else {
      default <- if (type == "int") "NA_INTEGER" else "NA_REAL"
    }
    obj$constant$add("%s = %s;", obj$rewrite(nm), default)
    get_user <- sprintf("get_user_%s", type)
    obj$library_fns$add(get_user)
    value <- sprintf("%s(%s, \"%s\", %s)", get_user, USER, nm, obj$rewrite(nm))
  } else {
    value <- obj$rewrite(x$rhs$value)
  }

  if (x$stage < STAGE_TIME || is_initial) {
    target$add("%s = %s;", obj$rewrite(nm), value, name=nm)
  } else if (identical(x$lhs$special, "deriv")) {
    target$add("%s[%s] = %s;",
               DSTATEDT,
               dat$variable_order$offset_use[[x$lhs$name_target]],
               value, name=nm)
  } else if (identical(x$lhs$special, "output")) {
    target$add("%s[%s] = %s;",
               OUTPUT, dat$output_order$offset_use[[nm]], value, name=nm)
  } else {
    target$add("%s %s = %s;", type, nm, value, name=nm)
  }
}

odin_generate_array <- function(x, obj, dat) {
  st <- STAGES[[x$stage]]
  nm <- x$name

  if (isTRUE(x$rhs$user)) {
    dim <- dat$eqs[[array_dim_name(x$name)]]
    if (isTRUE(dim$rhs$user)) {
      ## All done already while establishing dim
      return()
    }
    nd <- dim$nd
    fn <- sprintf("get_user_array%d", nd)
    obj$library_fns$add(fn)

    if (nd == 1) {
      dn <- obj$rewrite(dim$name)
    } else {
      dn <- paste(vcapply(seq_len(nd), function(i)
        obj$rewrite(array_dim_name(x$name, i)), USE.NAMES=FALSE), collapse=", ")
    }
    obj[[st]]$add('%s(%s, "%s", %s, %s);',
                  fn, USER, nm, dn, obj$rewrite(x$name), name=nm)
  } else {
    obj[[st]]$add(odin_generate_array_expr(x, obj), name=nm)
  }
}

odin_generate_array_expr <- function(x, obj) {
  ret <- collector()
  indent <- ""
  ## TODO: For >= 2 dimensions, consider running the indices
  ## backwards here to be more cache friendly.  So this means
  ## running k, then j, then i.  To do this well, store the offsets
  ## at each loop level.  See odin_sum2 and odin_sum3 for how this
  ## works.  I'm not really sure if this will actually make a
  ## performance gain, but it should be simple enough to implement.
  ## It's worth checking the code that compiler generates though
  ## actually differs (especially with -O2 or higher).
  for (j in seq_along(x$lhs$index)) {
    xj <- x$lhs$index[[j]]
    is_range <- xj$is_range
    target <- xj$extent_max
    ## TODO: The index variables need sanitising so that no more
    ## than one of i,j,k is allowed; things like x[i,j] = z[i + j]
    ## are not allowed!
    for (k in seq_along(is_range)) {
      if (is_range[k]) {
        ret$add("%sfor (int %s = %s; %s < %s; ++%s) {",
                indent,
                INDEX[[k]], minus1(xj$extent_min[[k]], obj$rewrite),
                INDEX[[k]], obj$rewrite(xj$extent_max[[k]]),
                INDEX[[k]])
        indent <- paste0("  ", indent)
        target[[k]] <- as.symbol(INDEX[[k]])
      } else if (INDEX[[k]] %in% x$rhs$depends$variables) {
        ## TODO: I need to get the index rhs depends back here to
        ## do this best (i.e., if the rhs does not depend on an
        ## index then don't bother adding the declaration here).
        ## As it is this will do this for *all* entries which is
        ## not ideal.
        if (!nzchar(indent)) {
          ret$add("{")
          indent <- "  "
        }
        ret$add("%sint %s = %s;", indent, INDEX[[k]],
                minus1(xj$extent_max[[k]], obj$rewrite))
        target[[k]] <- as.symbol(INDEX[[k]])
      } else {
        target[[k]] <- xj$extent_max[[k]]
      }
    }
    target <- obj$rewrite(as.call(c(quote(`[`), as.symbol(x$name), target)))
    value <- obj$rewrite(x$rhs$value[[j]])
    ret$add("%s%s = %s;", indent, target, value)

    while (nzchar(indent)) {
      indent <- substr(indent, 3L, nchar(indent))
      ret$add("%s}", indent)
    }
  }
  ret$get()
}

## TODO: I think I have some duplication here in both the variable
## ordering and the output ordering (computing offsets and the like).
## Here I'm hoping to make the simplifying assumption that the number
## of array variables stored is smallish so we can afford to manually
## do calculations on them.
odin_generate_delay <- function(x, obj, dat) {
  nm <- x$name
  delay_len <- length(x$delay$extract)
  delay_is_array <- x$delay$is_array
  ## This one is nasty:
  dep_is_array <- x$delay$dep_is_array

  delay_size <- vcapply(x$delay$size, obj$rewrite)
  ## Need to compute total array size here, with the 3 options of all
  ## array, no array or some array:
  if (all(delay_is_array)) {
    delay_size_tot <- paste(delay_size, collapse=" + ")
  } else if (any(delay_is_array)) {
    delay_size_tot <-
      paste(c(sum(!delay_is_array), delay_size[delay_is_array]),
            collapse=" + ")
  } else {
    delay_size_tot <- delay_len
  }

  ## NOTE: There's some duplication here in terms of the size of
  ## various arrays.  That helps with some assumptions about how
  ## the array allocations and copying works.  It's possible that
  ## could be worked around with a #define but I don't think it's
  ## worth it at this point.  For now just accept the redundancy.
  ##
  ## NOTE: it would be *heaps* simpler to extract the entire
  ## structure here (create one vector of length `p->dim` and set
  ## it as `0..(p->dim-1)` but potentially slower as it will look
  ## up all varaibles (and most of the time we won't be interested
  ## in all).
  ##
  ## TODO: The Calloc/Free calls here could move into contents if
  ## it took a stage argument.
  ##
  ## TODO: The Calloc/Free calls here are in danger of being incorrect
  ## here with user-sized array input.  I think that this just
  ## requires nailing the stage correctly, but there are some unusual
  ## dependencies for delay things (and we need to delay on the size
  ## for all given variables which is not currently supported
  ## properly)

  ## The options for naming are to use a series of indices (e.g., 1,
  ## 2, 3) or name things after the variables that are being delayed
  ## (delay_1_idx vs delay_lag_inf_idx, delay_1_state vs
  ## delay_lag_inf_state).  I think that the latter is probably nicer.
  delay_idx <- sprintf("delay_%s_%s", INDEX[[1L]], nm)
  delay_state <- sprintf("delay_%s_%s", STATE, nm)
  delay_dim <- array_dim_name(delay_idx)
  delay_time <- sprintf("delay_%s", TIME)

  ## If there are any arrays here we'll need to organise offsets.
  ## Rather than store the full offset vector I'll do this one by hand
  ## I think and let the compiler take care of it?  Getting this right
  ## will require a good test.  It's possible that this can be done
  ## with an accumulating variable as we'll need to get lengths here
  ## anyway.
  st <- STAGES[if (any(x$delay$is_array)) dat$dim_stage else STAGE_CONSTANT]

  obj$add_element(delay_idx, "int", 1L)
  obj$add_element(delay_state, "double", 1L)

  obj[[st]]$add("%s = %s;", obj$rewrite(delay_dim), delay_size_tot, name=nm)
  if (st == "user") { ## NOTE: duplicated from odin_generate_dim()
    obj[["constant"]]$add("%s = NULL;", obj$rewrite(delay_idx))
    obj[["constant"]]$add("%s = NULL;", obj$rewrite(delay_state))
    obj[["user"]]$add("Free(%s);", obj$rewrite(delay_idx))
    obj[["user"]]$add("Free(%s);", obj$rewrite(delay_state))
  }
  obj[[st]]$add("%s = (int*) Calloc(%s, int);",
                obj$rewrite(delay_idx), obj$rewrite(delay_dim), name=nm)
  obj[[st]]$add("%s = (double*) Calloc(%s, double);",
                obj$rewrite(delay_state), obj$rewrite(delay_dim), name=nm)
  obj$free$add("Free(%s);", obj$rewrite(delay_idx))
  obj$free$add("Free(%s);", obj$rewrite(delay_state))

  if (length(dat$delay_arrays) > 0L) {
    for (i in seq_along(dat$delay_arrays)) {
      nm <- dat$delay_arrays[[i]]
      size <- array_dim_name(names(dat$delay_arrays)[[i]])
      if (st == "user") { ## NOTE: duplicated from odin_generate_dim()
        obj[["constant"]]$add("%s = NULL;", obj$rewrite(nm))
        obj[["user"]]$add("Free(%s);", obj$rewrite(nm))
      }
      obj[[st]]$add("%s = (double*) Calloc(%s, double);",
                    obj$rewrite(nm), obj$rewrite(size), name=nm)
    }
  }

  ## Fill in the instructions for deSolve as to which variables we
  ## need delays for.  This is pretty hairy in the case of variables
  ## because we need to work across two sets of offsets that don't
  ## necessarily match up.  Note that the non-array things go in here
  ## before the array things.
  delay_var_offset <- dat$variable_order$offset_use[x$delay$extract]
  obj[[st]]$add("{", name=nm)
  obj[[st]]$add("  int j = 0;", name=nm)
  for (i in seq_along(delay_var_offset)) {
    if (x$delay$is_array[[i]]) {
      obj[[st]]$add("  for (int i = 0, k = %s; i < %s; ++i) {",
                    obj$rewrite(delay_var_offset[[i]]),
                    obj$rewrite(array_dim_name(x$delay$extract[[i]])),
                    name=nm)
      obj[[st]]$add("    %s[j++] = k++;", obj$rewrite(delay_idx), name=nm)
      obj[[st]]$add("  }", name=nm)
    } else {
      obj[[st]]$add("  %s[j++] = %s;", obj$rewrite(delay_idx),
                    obj$rewrite(delay_var_offset[[i]]), name=nm)
    }
  }
  obj[[st]]$add("}", name=nm)

  ## Next, prepare output variables so we can push them up out of scope:
  st <- STAGES[STAGE_TIME]
  if (x$lhs$type == "symbol") {
    obj[[st]]$add("double %s;", nm, name=nm)
  }
  obj[[st]]$add("{", name=nm)

  ## 4. Pull things out of the lag value, but only if time is past
  ## where the lag is OK to work with.  That's going to look like:
  obj[[st]]$add("  double %s;",
                paste0(ifelse(x$delay$is_array, "*", ""),
                       x$delay$extract, collapse=", "), name=nm)

  ## Next, we need to compute offsets.  This is annoying because it
  ## duplicates code elsewhere, but life goes on.  I'm running this
  ## one a bit differently though, in the hope that not too many ways.
  ##
  ## Here, we need, for the array case, to swap out the delay_state in
  ## place of the last array.  If I do that always it's less checking,
  ## actually.  This will always be of the form X + dim(X) so that's
  ## nice.
  f <- function(i) {
    if (identical(x$delay$offset[[i]], 0L) && x$delay$is_array[[i]]) {
      obj$rewrite(delay_state)
    } else {
      fmt <- if (x$delay$is_array[[i]]) "%s + %s" else "%s[%s]"
      if (i > 1L && x$delay$is_array[[i - 1L]]) {
        base <- x$delay$extract[[i - 1L]]
      } else {
        base <- obj$rewrite(delay_state)
      }
      sprintf(fmt, base, obj$rewrite(x$delay$offset[[i]]))
    }
  }
  delay_access <- vcapply(seq_along(x$delay$offset), f)

  ## TODO: if time is used in the time calculation it will need
  ## rewriting.  But I believe that parse prohibits that in the
  ## meantime.
  obj[[st]]$add("  const double %s = %s - %s;",
                delay_time, TIME, obj$rewrite(x$delay$time), name=nm)
  obj[[st]]$add("  if (%s <= %s) {",
                delay_time, obj$rewrite(sprintf("initial_%s", TIME)), name=nm)
  obj[[st]]$add("    %s = %s;",
                x$delay$extract,
                vcapply(sprintf("initial_%s", x$delay$extract),
                        obj$rewrite, USE.NAMES=FALSE), name=nm)
  obj[[st]]$add("  } else {", name=nm)
  ## TODO: This could be done on a switch in the parameters; that
  ## would enable dde and deSolve to exist side-by-side.
  lagvalue <-  sprintf("      lagvalue_%%s(%s, %s, %s, %s);",
                       delay_time,
                       obj$rewrite(delay_idx),
                       obj$rewrite(delay_dim),
                       obj$rewrite(delay_state))
  obj[[st]]$add("    if (%s->odin_use_dde) {", obj$name_pars, name=nm)
  obj[[st]]$add(lagvalue, "dde", name=nm)
  obj[[st]]$add("    } else {", name=nm)
  obj[[st]]$add(lagvalue, "ds", name=nm)
  obj[[st]]$add("    }", name=nm)
  obj[[st]]$add("    %s = %s;", x$delay$extract, delay_access, name=nm)
  obj[[st]]$add("  }", name=nm)

  ## Then we'll organise that whenever we hit a variable that is used
  ## in a delay statement we'll add it in here in the appropriate
  ## order.
  if (length(dat$delay_arrays) > 0L) {
    subs <- lapply(dat$delay_arrays, as.name)
    tr <- function(x) {
      if (x$name %in% names(subs)) {
        x$name <- dat$delay_arrays[[x$name]]
      }
      if (isTRUE(x$rhs$delay)) {
        ## This one is the actual target (last step in the process).
        x$rhs$value <- list(substitute_(x$rhs$value_expr, subs))
      } else {
        ## This one is an array used to generate the target.
        x$rhs$value <- lapply(x$rhs$value, substitute_, subs)
      }
      x
    }
  } else {
    tr <- identity
  }

  ## Here, identify and rewrite the arrays from the equation.
  for (nm_dep in x$delay$deps) {
    if (dep_is_array[[nm_dep]]) {
      obj[[st]]$add(indent(
                 odin_generate_array_expr(tr(dat$eqs[[nm_dep]]), obj), 2),
                 name=nm)
    } else {
      obj[[st]]$add("  double %s = %s;",
                    nm_dep, obj$rewrite(tr(dat$eqs[[nm_dep]])$rhs$value),
                    name=nm)
    }
  }
  if (x$lhs$type == "array") {
    obj[[st]]$add(indent(odin_generate_array_expr(tr(x), obj), 2), name=nm)
  } else {
    obj[[st]]$add("  %s = %s;", nm, obj$rewrite(tr(x)$rhs$value_expr),
                  name=nm)
  }
  obj[[st]]$add("}", name=nm)
}

## TODO: Consider a different prefix for these as the functions really
## fall into two phases; global collection and output.  Below here is
## all output and does not modify obj, except for the library_fns one.

## TODO: This aand generate_output_order do basically the same thing
## to two different sets of variables.  It would be good to abstract
## this away if that makes much sense because the new version is a bit
## of a terror.
odin_generate_order <- function(obj) {
  ret <- collector()
  vars <- obj[["vars"]]
  ret$add("// Report back to R information on variable ordering")
  ret$add("// The reported information includes position and length of each")
  ret$add("// variable, from which offset, etc, can be worked out.")
  ret$add("SEXP %s_order(SEXP %s_ptr) {", obj$base, obj$base)
  if (any(vars$is_array)) {
    ret$add("  %s *%s = %s_get_pointer(%s_ptr, 1);",
            obj$type_pars, obj$name_pars, obj$base, obj$base)
    if (max(vars$array) > 1L) {
      ret$add("  int *tmp;")
    }
  }
  ret$add("  SEXP %s_len = PROTECT(allocVector(VECSXP, %d));",
          STATE, nrow(vars))
  ret$add("  SEXP %s_names = PROTECT(allocVector(STRSXP, %d));",
          STATE, nrow(vars))

  for (i in seq_len(nrow(vars))) {
    nd <- vars$array[[i]]
    if (nd == 0L) {
      ret$add("  SET_VECTOR_ELT(%s_len, %s, R_NilValue);", STATE, i - 1L)
    } else if (nd == 1L) {
      ret$add("  SET_VECTOR_ELT(%s_len, %s, ScalarInteger(%s));",
              STATE, i - 1L, vars$length[[i]])
    } else {
      ret$add("  SET_VECTOR_ELT(%s_len, %s, allocVector(INTSXP, %d));",
              STATE, i - 1L, nd)
      ret$add("  tmp = INTEGER(VECTOR_ELT(%s_len, %s));", STATE, i - 1L)
      for (j in seq_len(nd)) {
        ret$add("  tmp[%d] = %s;", j - 1L,
                obj$rewrite(array_dim_name(vars$name[[i]], j)))
      }
    }
    ret$add("  SET_STRING_ELT(%s_names, %d, mkChar(\"%s\"));",
            STATE, i - 1L, vars$name[[i]])
  }
  ret$add("  setAttrib(%s_len, R_NamesSymbol, %s_names);", STATE, STATE)
  ret$add("  UNPROTECT(2);")
  ret$add("  return %s_len;", STATE)
  ret$add("}")
  ret$get()
}

odin_generate_output_order <- function(obj) {
  ret <- collector()
  ret$add("// Report back to R information on output variable ordering")
  ret$add("// Like the variable order above, but for any output vars")
  ret$add("// If no output variables are used, return an R NULL")
  ret$add("SEXP %s_output_order(SEXP %s_ptr) {", obj$base, obj$base)
  if (is.null(obj[["output_tmp"]])) {
    ret$add("  return R_NilValue;", STATE)
  } else {
    if (any(obj$output_tmp$array)) { # TODO: array > 0
      ret$add("  %s *%s = %s_get_pointer(%s_ptr, 1);",
              obj$type_pars, obj$name_pars, obj$base, obj$base)
    }
    ret$add("  SEXP %s_len = PROTECT(allocVector(INTSXP, %d));",
            STATE, nrow(obj[["output_tmp"]]))
    ret$add("  SEXP %s_names = PROTECT(allocVector(STRSXP, %d));",
            STATE, nrow(obj[["output_tmp"]]))
    i <- seq_len(nrow(obj[["output_tmp"]])) - 1L
    ret$add("  INTEGER(%s_len)[%s] = %s;", STATE, i, obj[["output_tmp"]]$length)
    ret$add("  SET_STRING_ELT(%s_names, %d, mkChar(\"%s\"));",
            STATE, i, obj[["output_tmp"]]$name)
    ret$add("  setAttrib(%s_len, R_NamesSymbol, %s_names);", STATE, STATE)
    ret$add("  UNPROTECT(2);")
    ret$add("  return %s_len;", STATE)
  }
  ret$add("}")
  ret$get()
}

odin_generate_contents <- function(obj) {
  types <- obj$types
  len <- nrow(types)

  rtype <- c(int="INTSXP", double="REALSXP")
  raccess <- c(int="INTEGER", double="REAL")

  ret <- collector()
  ret$add("// Translate all elements in the struct back to R")
  ret$add("// This will mostly be useful for debugging.")
  ret$add("SEXP %s_contents(SEXP %s_ptr) {", obj$base, obj$base)
  ret$add("  %s *%s = %s_get_pointer(%s_ptr, 1);",
          obj$type_pars, obj$name_pars, obj$base, obj$base)
  ret$add("  SEXP %s = PROTECT(allocVector(VECSXP, %d));",
          STATE, len)
  for (i in seq_len(len)) {
    name <- types$name[[i]]
    type <- types$type[[i]]
    array <- types$array[[i]]
    if (array > 0L) {
      name_dim <- array_dim_name(name)
      ret$add("  SET_VECTOR_ELT(%s, %d, allocVector(%s, %s));",
                   STATE, i - 1L, rtype[[type]], obj$rewrite(name_dim))
      ret$add("  memcpy(%s(VECTOR_ELT(%s, %d)), %s, %s * sizeof(%s));",
              raccess[[type]], STATE, i - 1L, obj$rewrite(name),
              obj$rewrite(name_dim), type)
      ## TODO: Should add something here for multidimensional arrays
      ## to get the dimension set, I think; but we also need a
      ## function to do that for the output vector (and that's hard
      ## because we don't have a nice way of accessing that yet due to
      ## the time axis of the output).
      if (array > 1L) {
        ret$add("  odin_set_dim%d(VECTOR_ELT(%s, %d), %s);",
                array, STATE, i - 1L,
                paste(vcapply(seq_len(array), function(j)
                  obj$rewrite(array_dim_name(name, j))), collapse=", "))
      }
    } else {
      type <- if (type == "int") "Integer" else "Real"
      ret$add("  SET_VECTOR_ELT(%s, %d, Scalar%s(%s));",
              STATE, i - 1L, type, obj$rewrite(name))
    }
  }

  ret$add("  SEXP %s_names = PROTECT(allocVector(STRSXP, %d));",
          STATE, len)
  ret$add('  SET_STRING_ELT(%s_names, %d, mkChar("%s"));',
          STATE, seq_len(len) - 1L, types$name)

  ret$add("  setAttrib(%s, R_NamesSymbol, %s_names);", STATE, STATE)
  ret$add("  UNPROTECT(2);")
  ret$add("  return %s;", STATE)
  ret$add("}")

  ret$get()
}

odin_generate_struct <- function(obj) {
  types <- obj$types
  ret <- collector()
  ret$add("// Collect together all the parameters and transient memory")
  ret$add("// required to run the model in a struct.")
  ret$add("typedef struct %s {", obj$type_pars)
  ret$add("  %s %s%s;", types$type, ifelse(types$array, "*", ""), types$name)
  ret$add("} %s;", obj$type_pars)
  ret$get()
}

odin_generate_finalize <- function(obj) {
  ret <- collector()
  ret$add("// Arrange to free all memory we have allocated")
  ret$add("// This is called by R automatically when the pointer is")
  ret$add("// garbage collected (i.e., when all objects holding the pointer")
  ret$add("// go out of scope")
  ret$add("void %s_finalize(SEXP %s_ptr) {", obj$base, obj$base)
  ret$add("  %s *%s = %s_get_pointer(%s_ptr, 0);",
          obj$type_pars, obj$name_pars, obj$base, obj$base)
  ret$add("  if (%s_ptr) {", obj$base)
  free <- obj$free$get()
  if (length(free) > 0L) {
    ret$add(indent(free, 4))
  }
  ret$add("    Free(%s);", obj$name_pars)
  ret$add("    R_ClearExternalPtr(%s_ptr);", obj$base)
  ret$add("  }")
  ret$add("}")

  ## We need a declaration for this one.  However, if things get
  ## broken up into a header and nonheader file this will need
  ## injecting into the nonheader file I think.  For now it's fine.

  ret$get()
}

odin_generate_create <- function(obj) {
  ret <- collector()
  ret$add("// Create the pointer; this will establish the struct, allocate")
  ret$add("// memory for things that are constant size, and initialize")
  ret$add("// constant variables")
  ## See odin_generate_finalize(); we need to declare the finalizer here.
  ret$add("static void %s_finalize(SEXP %s_ptr);", obj$base, obj$base)
  ret$add("SEXP %s_create(SEXP %s, SEXP odin_use_dde) {", obj$base, USER)
  ret$add("  %s *%s = (%s*) Calloc(1, %s);",
          obj$type_pars, obj$name_pars, obj$type_pars, obj$type_pars)
  constant <- obj$constant$get()
  if (length(constant) > 0L) {
    ret$add(indent(constant, 2))
  }
  ret$add(
    "  SEXP %s_ptr = PROTECT(R_MakeExternalPtr(%s, R_NilValue, R_NilValue));",
    obj$base, obj$name_pars)
  ret$add("  R_RegisterCFinalizer(%s_ptr, %s_finalize);", obj$base, obj$base)
  ## NOTE: set user variables *after* creating the pointer and
  ## finaliser to avoid any memory leak in the case of set_user
  ## failing (as it throws on failure so the Free's would never
  ## happen.
  ret$add("  %s_set_user(%s, %s);", obj$base, obj$name_pars, USER)
  ret$add("  %s->odin_use_dde = INTEGER(odin_use_dde)[0];", obj$name_pars)
  ret$add("  UNPROTECT(1);")
  ret$add("  return %s_ptr;", obj$base)
  ret$add("}")
  ret$get()
}

odin_generate_user <- function(obj) {
  ret <- collector()
  ret$add("// Set user-supplied parameter values.")
  ret$add("SEXP %s_set_user(%s *%s, SEXP %s) {",
          obj$base, obj$type_pars, obj$name_pars, USER)
  user <- obj$user$get()
  if (length(user) > 0L) {
    ret$add(indent(user, 2))
  }
  ret$add("  return R_NilValue;")
  ret$add("};")
  ret$add("// Wrapper around this for use from R.")
  ret$add("SEXP r_%s_set_user(SEXP %s_ptr, SEXP %s) {",
          obj$base, obj$base, USER)
  ret$add("  %s *%s = %s_get_pointer(%s_ptr, 1);",
          obj$type_pars, obj$name_pars, obj$base, obj$base)
  ret$add("  %s_set_user(%s, %s);", obj$base, obj$name_pars, USER)
  ret$add("  return R_NilValue;")
  ret$add("};")
  ret$get()
}

## TODO: for %s_ptr, use odin_ptr (<base>_ptr) or use <obj$type_pars>_ptr?
odin_generate_initial <- function(obj) {
  ret <- collector()
  ret$add("SEXP %s_initialise(SEXP %s_ptr, SEXP %s_ptr) {",
          obj$base, obj$base, TIME)
  ret$add("  %s *%s = %s_get_pointer(%s_ptr, 1);",
          obj$type_pars, obj$name_pars, obj$base, obj$base)

  initial <- obj$initial$get()
  if (obj$info$has_delay || length(initial) > 0L) {
    ret$add("  const double %s = REAL(%s_ptr)[0];", TIME, TIME)
  }
  if (obj$info$has_delay) {
    ret$add("  %s = %s;", obj$rewrite(sprintf("initial_%s", TIME)), TIME)
  }
  if (length(initial) > 0L) {
    ret$add(indent(initial, 2))
  }

  ## It's possible this bit should be factored out into a separate function?
  ret$add("  SEXP %s = PROTECT(allocVector(REALSXP, %s));",
          STATE, obj$variable_size)
  copy <- character(nrow(obj[["vars"]]))
  i <- obj[["vars"]]$is_array
  nm_initial <- vcapply(sprintf("initial_%s", obj[["vars"]]$name), obj$rewrite)
  copy[i] <- sprintf("  memcpy(REAL(%s) + %s, %s, %s * sizeof(double));",
                     STATE, obj[["vars"]]$offset[i], nm_initial[i],
                     obj[["vars"]]$length[i])
  copy[!i] <- sprintf("  REAL(%s)[%s] = %s;",
                      STATE, obj[["vars"]]$offset[!i], nm_initial[!i])
  ret$add(copy)
  if (!is.null(obj[["output_tmp"]])) {
    ret$add('  setAttrib(%s, install("%s_len"), ScalarInteger(%s));',
            STATE, OUTPUT, obj$output_size)
  }
  ret$add("  UNPROTECT(1);")
  ret$add("  return %s;", STATE)
  ret$add("}")
  ret$get()
}

## OK, this one is slightly complicated because there are *three*
## forms of the derivative function.  The base one (that this does)
## returns void and takes a pointer.
odin_generate_deriv <- function(obj) {
  vars <- obj[["vars"]]
  ret <- collector()

  ret$add(
    "void %s_deriv(%s *%s, double %s, double *%s, double *%s, double *%s) {",
    obj$base, obj$type_pars, obj$name_pars, TIME, STATE, DSTATEDT, OUTPUT)
  v <- odin_generate_vars(obj)
  if (length(v) > 0L) {
    ret$add(indent(v, 2))
  }
  if (any(vars$is_array)) {
    ret$add("  double *deriv_%s = %s + %s;",
            vars$name[vars$is_array], DSTATEDT, vars$offset[vars$is_array])
  }
  time <- obj$time$get()
  if (length(time) > 0L) {
    ret$add(indent(time, 2))
  }

  ## The conditional here means that we'll be able to be compatible
  ## with both dde and deSolve, as they totally differ in how output
  ## variables are computed.  We pass a NULL through for output for
  ## dde so this will skip pretty happily.
  output <- obj$output$get()
  if (length(output) > 0L) {
    ret$add("  if (%s != NULL) {", OUTPUT)
    ret$add(indent(output, 4))
    ret$add("  }")
  }
  ret$add("}")
  ret$get()
}

odin_generate_output <- function(obj) {
  if (!obj$info$has_output) {
    return(NULL)
  }
  output <- obj$output$get()

  ret <- collector()
  ret$add(
    "void %s_output(%s *%s, double %s, double *%s, double *%s) {",
    obj$base, obj$type_pars, obj$name_pars, TIME, STATE, OUTPUT)

  ## Here we unpack:

  ## 1. variables that we need to use
  v <- odin_generate_vars(obj, TRUE)
  if (length(v) > 0L) {
    ret$add(indent(v, 2))
  }

  ## 2. dependent calculations
  time <- obj$time$get()
  time <- time[names(time) %in% obj$output_exprs]
  if (length(time) > 0L) {
    ret$add(time)
  }

  ## 3. the actual output calculations:
  ret$add(indent(output, 2))
  ret$add("}")
  ret$get()
}

odin_generate_library_fns <- function(obj) {
  dat <- read_user_c(system.file("library.c", package="odin"))
  fns <- obj$library_fns$get()
  if (any(grepl("^get_user_", fns))) {
    fns <- c(fns, "get_list_element")
  }
  fns <- unique(fns)
  list(declarations=c(unname(dat$declarations[fns]),
                      unname(obj$custom$declarations)),
       definitions=c(unname(dat$definitions[fns]),
                     unname(obj$custom$definitions)))
}

## NOTE: This does violate the idea that these leave obj unmodified;
## this adds a declaration for the get_pointer function.  These
## _always_ get added so add in the loop function perhaps?
odin_generate_support <- function(obj) {
  obj$declarations$add("%s* %s_get_pointer(SEXP %s_ptr, int closed_error);",
                       obj$type_pars, obj$base, obj$base)
  obj$declarations$add("SEXP %s_set_user(%s *%s, SEXP %s);",
                       obj$base, obj$type_pars, obj$name_pars, USER)

  ret <- collector()
  ret$add("%s* %s_get_pointer(SEXP %s_ptr, int closed_error) {",
          obj$type_pars, obj$base, obj$base)
  ret$add("  %s *%s = NULL;", obj$type_pars, obj$name_pars)
  ret$add("  if (TYPEOF(%s_ptr) != EXTPTRSXP) {", obj$base)
  ret$add('    Rf_error("Expected an external pointer");')
  ret$add("  }")
  ret$add("  %s = (%s*) R_ExternalPtrAddr(%s_ptr);",
          obj$name_pars, obj$type_pars, obj$base)
  ret$add("  if (!%s && closed_error) {", obj$name_pars)
  ret$add('    Rf_error("Pointer has been invalidated");')
  ret$add("  }")
  ret$add("  return %s;", obj$name_pars)
  ret$add("}")
  ret$get()
}

odin_generate_deriv_r <- function(obj) {
  ret <- collector()
  ret$add("SEXP r_%s_deriv(SEXP %s_ptr, SEXP %s, SEXP %s) {",
          obj$base, obj$base, TIME, STATE)
  ret$add("  SEXP %s = PROTECT(allocVector(REALSXP, LENGTH(%s)));",
          DSTATEDT, STATE)
  ret$add("  %s *%s = %s_get_pointer(%s_ptr, 1);",
          obj$type_pars, obj$name_pars, obj$base, obj$base)

  if (is.null(obj$output_tmp)) {
    ret$add("  double *%s = NULL;", OUTPUT)
    np <- 1L
  } else {
    ret$add("  SEXP %s_ptr = PROTECT(allocVector(REALSXP, %s));",
            OUTPUT, obj$output_size)
    ret$add('  setAttrib(%s, install("%s"), %s_ptr);', DSTATEDT, OUTPUT, OUTPUT)
    ret$add("  double *%s = REAL(%s_ptr);", OUTPUT, OUTPUT)
    np <- 2L
  }

  ret$add("  %s_deriv(%s, REAL(%s)[0], REAL(%s), REAL(%s), %s);",
          obj$base, obj$name_pars, TIME, STATE, DSTATEDT, OUTPUT)
  ret$add("  UNPROTECT(%d);", np)
  ret$add("  return %s;", DSTATEDT)
  ret$add("}")
  ret$get()
}

odin_generate_desolve <- function(obj) {
  ret <- collector()
  ret$add("// deSolve interface")
  ret$add("// Global variable set on initmod, as per deSolve design")
  ret$add("static %s *%s;", obj$type_pars, obj$name_pars)
  ret$add("void %s_ds_initmod(void(* odeparms) (int *, double *)) {",
          obj$base)
  ret$add('  DL_FUNC get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");')
  ret$add("  %s = %s_get_pointer(get_deSolve_gparms(), 1);",
          obj$name_pars, obj$base)
  ret$add("}")
  ret$add("void %s_ds_derivs(int *neq, double *%s, double *%s,",
          obj$base, TIME, STATE)
  ret$add("%sdouble *%s, double *%s, int *np) {",
          strrep(nchar(obj$base) + 15L), DSTATEDT, OUTPUT)
  ret$add("  %s_deriv(%s, *%s, %s, %s, %s);",
          obj$base, obj$name_pars, TIME, STATE, DSTATEDT, OUTPUT)
  ret$add("}")
  ret$get()
}

odin_generate_dde <- function(obj) {
  ret <- collector()
  ret$add("// dde interface")
  ret$add("void %s_dde_derivs(size_t n_eq, double %s, double *%s,",
          obj$base, TIME, STATE)
  ret$add("%sdouble *%s, void *%s) {",
          strrep(nchar(obj$base) + 17L), DSTATEDT, obj$name_pars)
  ret$add("  %s_deriv((%s*)%s, %s, %s, %s, NULL);",
          obj$base, obj$type_pars, obj$name_pars, TIME, STATE, DSTATEDT)
  ret$add("}")

  if (obj$info$has_output) {
    ## This needs working through because we don't want to get the
    ## output at every derivative calculation (that's wasteful), and
    ## because the dde solver does not actually stop at all the
    ## requested points it does need to be done in two stages.  So
    ## this will require some extra faff with generating output
    ## functions, which requires another trip through the DAG too.

    ## Here, we'll need to have done some output processing.
    ret$add("\nvoid %s_dde_output(size_t n_eq, double %s, double *%s,",
            obj$base, TIME, STATE)
    ret$add("%ssize_t dim_%s, double *%s, void *%s) {",
            strrep(nchar(obj$base) + 17L), OUTPUT, OUTPUT, obj$name_pars)
    ret$add("  %s_output((%s*)%s, %s, %s, %s);",
            obj$base, obj$type_pars, obj$name_pars, TIME, STATE, OUTPUT)
    ret$add("}")
  }
  ret$get()
}

odin_generate_info <- function(obj) {
  info <- obj$info
  ret <- collector()
  ret$add("// Report back to R some key features of the system of ODEs")
  ret$add("// These are truely constant features of the model -- not to do")
  ret$add("// with any specific realisation of the model, so we don't need")
  ret$add("// or want a pointer here.  Things like output length, variable")
  ret$add("// length etc might vary depending on parameters used to generate")
  ret$add("// the model so we'll pull those elsewhere")
  ret$add("SEXP %s_info() {", obj$base)
  ret$add("  SEXP ret = PROTECT(allocVector(VECSXP, %d));", length(info))
  ret$add("  SEXP nms = PROTECT(allocVector(STRSXP, %d));", length(info))
  as_vector <- vlapply(info, function(x)
                       length(x) > 1 || (length(x) > 0 && !is.null(names(x))))
  if (any(as_vector)) {
    ret$add("  SEXP tmp;")
  }
  for (i in seq_along(info)) {
    x <- info[[i]]
    ret$add('  SET_STRING_ELT(nms, %d, mkChar("%s"));',
            i - 1L, names(info)[[i]])
    if (length(x) == 0L) {
      ret$add('  SET_VECTOR_ELT(ret, %d, R_NilValue);', i - 1L)
    } else if (!as_vector[[i]]) {
      ## The names length check is required to avoid a weirdness in
      ## the R API here:
      ## https://stat.ethz.ch/pipermail/r-devel/2014-October/070010.html
      if (is.character(x)) {
        ret$add('  SET_VECTOR_ELT(ret, %d, mkString("%s"));', i - 1L, x)
      } else {
        fn <- if (is.logical(x)) "ScalarLogical" else "ScalarInteger"
        ret$add('  SET_VECTOR_ELT(ret, %d, %s(%d));',
                i - 1L, fn, as.integer(x))
      }
    } else {
      sxp <- switch(storage.mode(x),
                    logical="LGLSXP",
                    character="STRSXP")
      ret$add('  tmp = PROTECT(allocVector(%s, %d));', sxp, length(x))
      j <- seq_along(x) - 1L
      if (is.character(x)) {
        ret$add('  SET_STRING_ELT(tmp, %d, mkChar("%s"));', j, x)
      } else {
        ret$add('  INTEGER(tmp)[%d] = %d;', j, as.integer(x))
      }
      ret$add('  SET_VECTOR_ELT(ret, %d, tmp);', i - 1L)
      ret$add('  UNPROTECT(1);')
    }
    if (length(x) > 0L && !is.null(names(x))) {
      if (length(x) == 1L) {
        ret$add(
          '  setAttrib(VECTOR_ELT(ret, %d), R_NamesSymbol, mkString("%s"));',
          i - 1L, names(x))
      } else {
        ret$add('  tmp = PROTECT(allocVector(STRSXP, %d));', length(x))
        ret$add('  SET_STRING_ELT(tmp, %d, mkChar("%s"));', j, names(x))
        ret$add('  setAttrib(VECTOR_ELT(ret, %d), R_NamesSymbol, tmp);',
                i - 1L)
        ret$add('  UNPROTECT(1);')
      }
    }
  }
  ret$add("  setAttrib(ret, R_NamesSymbol, nms);")
  ret$add("  UNPROTECT(2);")
  ret$add("  return ret;")
  ret$add("}")
  ret$get()
}

## Read a bunch of library functions.  The format here is important.
##
## This could be relaxed soon, though doing it correctly will require
## things like a proper C parser.  A more sensible route forward would
## be to allow, in addition, arbitrary functions to be listed with the
## inclusion of a header file.
read_user_c <- function(filename) {
  d <- readLines(filename)
  re <- "^[[:alnum:]*]+ ([[:alnum:]_]+)(.+) \\{$"
  i <- grep(re, d)
  j <- grep("^}$", d)
  if (length(i) != length(j)) {
    stop("Parse error for ", filename)
  }

  name <- sub(re, "\\1", d[i])
  decl <- setNames(sub(" \\{$", ";", d[i]), name)
  defn <- setNames(vcapply(seq_along(i), function(k)
    paste(d[i[[k]]:j[[k]]], collapse="\n")), name)
  list(declarations=decl, definitions=defn)
}

array_dim_name <- function(name, sub=NULL, use=TRUE) {
  if (!is.null(sub)) {
    name <- sprintf("%s_%s", name, sub)
  }
  if (grepl("^(initial|deriv)_", name)) {
    name_dim <- sub("^(initial|deriv)_", "dim_", name)
  } else if (grepl("^delay_", name)) {
    re <- "^delay_([^_]+)_(.*)$"
    type <- sub(re, "\\1", name)
    if (type == INDEX[[1L]] || (use && type == STATE)) {
      name_dim <- sub(re, "dim_delay_\\2", name)
    } else if (use) {
      name_dim <- sub("^delay_", "dim_", name)
    } else {
      name_dim <- NULL
    }
  } else {
    name_dim <- sprintf("dim_%s", name)
  }
  name_dim
}

## TODO: make this work for the output variables with an additional
## argument.
odin_generate_vars <- function(obj, output=FALSE) {
  vars <- obj[["vars"]]
  vars <- vars[if (output) vars$used_output else vars$used, ]
  ret <- collector()
  if (any(!vars$is_array)) {
    ret$add("double %s = %s[%s];",
            vars$name[!vars$is_array], STATE, vars$offset[!vars$is_array])
  }
  if (any(vars$is_array)) {
    ret$add("double *%s = %s + %s;",
            vars$name[vars$is_array], STATE, vars$offset[vars$is_array])
  }
  ret$get()
}
