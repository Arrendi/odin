## Welcome to the sausage factory!

## There are two stages to the generation:
##
## 1. first is the odin_generate1*; During this phase we build up and
##    modify an 'obj' which contains the information required to
##    generate the model.  If the model has made it through the parse
##    stage, any error there will be a odin error (hopefully).
##
## 2. second is odin_generate2*; all functions work on this object to
##    generate a character vector to put somewhere.  These are much
##    simpler generate the actual code.
odin_generate <- function(dat, dest=tempdir(), package=FALSE) {
  obj <- odin_generate1(dat)

  struct <- c(odin_generate2_struct(obj),
              odin_generate2_support_decls(obj))
  library_fns <- odin_generate2_library_fns(obj)

  ## NOTE: For now, the interpolation functions are just slurped in
  ## here.  This should do approximately the right thing for both
  ## standalone code and for packages.  But it's not pretty.  I might
  ## move to a more formal linking (e.g., getCcallable) approach but
  ## that considerably complicates compilation and may come with a
  ## slight performance cost too.
  discrete <- obj$info$discrete

  ## Then attempt to make some sense out of the things that we have
  ## collected:
  ##
  ## NOTE: if onefile is TRUE then there's no need to include the
  ## interpolation types or the function declarations (and in fact we
  ## don't probably *want* to do that?)
  ret <- list(if (!package) odin_header(),
              if (!package) odin_includes(),
              if (!package) struct,
              if (!package) library_fns$declarations,
              odin_generate2_create(obj),
              odin_generate2_user(obj),
              odin_generate2_finalize(obj),
              odin_generate2_initial(obj),
              odin_generate2_set_initial(obj),
              odin_generate2_deriv(obj),
              if (!discrete) odin_generate2_output(obj),
              if (!discrete) odin_generate2_deriv_desolve(obj),
              if (!discrete) odin_generate2_deriv_dde(obj),
              if ( discrete) odin_generate2_update_dde(obj),
              odin_generate2_deriv_r(obj),
              odin_generate2_contents(obj),
              odin_generate2_order(obj),
              odin_generate2_order(obj, TRUE),
              odin_generate2_interpolate_t(obj),
              odin_generate2_support_defns(obj),
              if (!package) library_fns$definitions)

  ret <- ret[lengths(ret) > 0]

  txt <- paste(vcapply(ret, paste, collapse="\n"),
               collapse="\n\n")

  if (package) {
    list(struct=struct, code=txt, library_fns=library_fns, info=obj$info)
  } else {
    if (is_directory(dest) || !grepl(".", basename(dest), fixed=TRUE)) {
      dest <- file.path(dest, sprintf("%s.c", obj$info$base))
    }
    writeLines(txt, dest)
    dest
  }
}

odin_header <- function() {
 c("// This file was automatically generated by odin.",
   "// Do not edit by hand as changes will be lost.")
}

odin_includes <- function() {
  c("#include <R.h>",
    "#include <Rmath.h>",
    "#include <Rinternals.h>",
    "#include <R_ext/Rdynload.h>",
    "#include <stdbool.h>")
}

## Read a bunch of library functions.  The format here is important.
##
## This could be relaxed soon, though doing it correctly will require
## things like a proper C parser.  A more sensible route forward would
## be to allow, in addition, arbitrary functions to be listed with the
## inclusion of a header file.
read_user_c <- function(filename) {
  d <- readLines(filename)
  re <- "^[[:alnum:]_*]+ ([[:alnum:]_]+)(.+)\\s*\\{$"
  i <- grep(re, d)
  j <- grep("^}$", d)
  if (length(i) != length(j)) {
    stop("Parse error for ", filename)
  }

  name <- sub(re, "\\1", d[i])
  decl <- setNames(sub(" \\{$", ";", d[i]), name)
  defn <- setNames(vcapply(seq_along(i), function(k)
    paste(d[i[[k]]:j[[k]]], collapse="\n")), name)
  list(declarations=decl, definitions=defn)
}
