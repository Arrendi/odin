## Welcome to the sausage factory!

## There are two stages to the generation:
##
## 1. first is the odin_generate1*; During this phase we build up and
## modify an 'obj'.
##
## 2. second is odin_generate2*; all functions work on this object to
## generate a character vector to put somewhere.  This is all of
## odin_generate *except* the first line.
odin_generate <- function(dat, dest=tempdir(), package=FALSE) {
  obj <- odin_generate1_loop(dat)
  support <- odin_generate2_support_defns(obj)
  library_fns <- odin_generate2_library_fns(obj)

  ## NOTE: For now, the interpolation functions are just slurped in
  ## here.  This should do approximately the right thing for both
  ## standalone code and for packages.  But it's not pretty.  I might
  ## move to a more formal linking (e.g., getCcallable) approach but
  ## that considerably complicates compilation and may come with a
  ## slight performance cost too.
  if (obj$info$has_interpolate) {
    interpolate <- odin_interpolate_support()
  } else {
    interpolate <- NULL
  }

  struct <- c(odin_generate2_struct(obj),
              odin_generate2_support_decls(obj))

  ## Then attempt to make some sense out of the things that we have
  ## collected:
  ##
  ## NOTE: if onefile is TRUE then there's no need to include the
  ## interpolation types or the function declarations (and in fact we
  ## don't probably *want* to do that?)
  ret <- list(if (!package) odin_header(),
              if (!package) odin_includes(),
              if (!package) interpolate$types,
              if (!package) struct,
              if (!package) obj$declarations$get(),
              if (!package) library_fns$declarations,
              if (!package) interpolate$declarations,
              odin_generate2_create(obj),
              odin_generate2_user(obj),
              odin_generate2_finalize(obj),
              odin_generate2_initial(obj),
              odin_generate2_deriv(obj),
              odin_generate2_deriv_r(obj),
              odin_generate2_contents(obj),
              odin_generate2_order(obj),
              odin_generate2_output_order(obj),
              odin_generate2_output(obj),
              odin_generate2_interpolate_t(obj),
              odin_generate2_desolve(obj),
              odin_generate2_dde(obj),
              odin_generate2_info(obj),
              odin_generate2_support_defns(obj),
              if (!package) library_fns$definitions,
              if (!package) interpolate$definitions)

  ret <- ret[lengths(ret) > 0]

  txt <- paste(vcapply(ret, paste, collapse="\n"),
               collapse="\n\n")

  if (package) {
    list(struct=struct, code=txt,
         library_fns=library_fns, base=obj$base, info=obj$info)
  } else if (is.null(dest)) {
    ## Here we'll return the actual contents:
    txt
  } else {
    if (is_directory(dest) || !grepl(".", basename(dest), fixed=TRUE)) {
      dest <- file.path(dest, sprintf("%s.c", obj$base))
    }
    writeLines(txt, dest)
    dest
  }
}

odin_header <- function() {
 c("// This file was automatically generated by odin.",
   "// Do not edit by hand as changes will be lost.")
}

odin_includes <- function() {
  c("#include <R.h>",
    "#include <Rinternals.h>",
    "#include <R_ext/Rdynload.h>")
}

odin_interpolate_support <- function() {
  type <- readLines(system.file("interpolate_types.h", package="odin"))
  decl <- readLines(system.file("interpolate_decls.h", package="odin"))
  defn <- readLines(system.file("interpolate.c", package="odin"))
  ## This is error prone but tests should catch it.  We mostly need
  ## not to include "interpolate.h" here.
  i <- grep("^(//|#include|$)", defn, perl=TRUE)
  j <- seq_len(max(which(i == seq_along(i))))
  if (length(j) > 0L) {
    defn <- defn[-j]
  }
  list(types=type, declarations=decl, definitions=defn)
}

## Read a bunch of library functions.  The format here is important.
##
## This could be relaxed soon, though doing it correctly will require
## things like a proper C parser.  A more sensible route forward would
## be to allow, in addition, arbitrary functions to be listed with the
## inclusion of a header file.
read_user_c <- function(filename) {
  d <- readLines(filename)
  re <- "^[[:alnum:]_*]+ ([[:alnum:]_]+)(.+)\\s*\\{$"
  i <- grep(re, d)
  j <- grep("^}$", d)
  if (length(i) != length(j)) {
    stop("Parse error for ", filename)
  }

  name <- sub(re, "\\1", d[i])
  decl <- setNames(sub(" \\{$", ";", d[i]), name)
  defn <- setNames(vcapply(seq_along(i), function(k)
    paste(d[i[[k]]:j[[k]]], collapse="\n")), name)
  list(declarations=decl, definitions=defn)
}

array_dim_name <- function(name, sub=NULL, use=TRUE) {
  if (length(name) > 1L) {
    return(vcapply(name, array_dim_name, sub, use, USE.NAMES=FALSE))
  }
  if (!is.null(sub)) {
    name <- sprintf("%s_%s", name, sub)
  }
  if (grepl("^(initial|deriv)_", name)) {
    name_dim <- sub("^(initial|deriv)_", "dim_", name)
  } else if (grepl("^delay_", name)) {
    re <- "^delay_([^_]+)_(.*)$"
    type <- sub(re, "\\1", name)
    if (type == INDEX[[1L]] || (use && type == STATE)) {
      name_dim <- sub(re, "dim_delay_\\2", name)
    } else if (use) {
      name_dim <- sub("^delay_", "dim_", name)
    } else {
      name_dim <- NULL
    }
  } else {
    name_dim <- sprintf("dim_%s", name)
  }
  name_dim
}

delay_name <- function(name) {
  sprintf("delay_%s", name)
}
