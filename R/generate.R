odin_generate <- function(dat, base="odin", dest=tempfile()) {
  obj <- odin_generate_loop(dat, base)
  ## This one is special because it fills up declarations; it miust be
  ## run first.
  support <- odin_generate_support(obj)
  library_fns <- odin_generate_library_fns(obj)
  declarations <- c(obj$declarations$get(), library_fns$declarations)

  header <- c("// This is automatically generated by odin.",
              "// Do not edit by hand as changes will be lost.",
              "#include <R.h>",
              "#include <Rinternals.h>",
              "#include <R_ext/Rdynload.h>")

  ## Then attempt to make some sense out of the things that we have
  ## collected:
  ret <- list(header,
              odin_generate_struct(obj),
              declarations,
              create=odin_generate_create(obj),
              odin_generate_finalize(obj),
              odin_generate_initial(obj),
              deriv=odin_generate_deriv(obj),
              odin_generate_deriv_r(obj),
              odin_generate_contents(obj),
              odin_generate_order(obj),
              odin_generate_desolve(obj),
              support,
              library_fns$definitions)

  txt <- paste(vcapply(ret, paste, collapse="\n"),
               collapse="\n\n")
  writeLines(txt, dest)
  dest
}

## What we are going to write here is a little bit of (fairly nasty)
## reference-style code that will help generate the inteface.  The
## simplest way of doing this might be to generate a small list of
## types that we can reference everywhere.  But that might just be
## more complicated than it needs to be?
odin_generate_object <- function(base, dat) {
  self <- list(base=base)

  self$name_pars <- sprintf("%s_p", base)
  self$type_pars <- sprintf("%s_pars", base)

  ## This is the set of variables we know to be *ours*.
  lookup <- collector()

  ## Rewrite based on that.
  self$rewrite <- function(x) {
    rewrite_c(x, self$name_pars, lookup$get(), INDEX)
  }

  ## Type information will generate a bunch of extra things, so
  ## process that later for simplicity:
  self$types <- collector_list()

  ## Create, initialise, derivatives
  self$constant <- collector()
  self$initial <- collector()
  self$time <- collector()

  self$free <- collector()

  ## Only used for delay models.
  self$delay <- vector("list", length(dat$delay))

  ## Keep track of which library functions we need.  I'll keep those
  ## elsewhere and select them based on name.
  self$library_fns <- collector()
  self$declarations <- collector()

  self$add_element <- function(name, type, array) {
    if (array) {
      if (grepl("^initial_", name)) {
        name_dim <- sub("^initial_", "dim_", name)
      } else if (grepl("^delay_", name)) {
        message("generate delay dim name")
      } else {
        name_dim <- sprintf("dim_%s", name)
      }
      Recall(name_dim, "int", FALSE)
    }
    self$types$add(list(name=name, type=type, array=array))
    lookup$add(name)
  }
  self
}

## TODO: Disallow '<base>_' as a name; otherwise potential for
## collision, so probably set that in the DSL rather than here.
odin_generate_loop <- function(dat, base) {
  obj <- odin_generate_object(base, dat)

  ## Set up initial time so we can refer to it later.  Not all models
  ## make use of this, but it seems worth adding (and doesn't take
  ## that much space).  Delay models will make extensive use of this.
  ## We could omit this for any non-delay model perhaps?
  ##
  ## TODO: support general RHS rewriting of initial(x) -> initial_x
  ## combined with parse-time checking of valid x.
  obj$add_element(sprintf("initial_%s", TIME), "double", FALSE)

  ## We'll always need this.
  obj$library_fns$add("get_ds_pars")
  fns <- unique(unlist(lapply(dat$eqs, function(x) x$depends$functions)))
  if ("sum" %in% fns) {
    obj$library_fns$add("odin_sum")
  }

  ## This is not going to be used everywhere, but these need to be
  ## determined before the rest of the processing because they imply
  ## another level of grouping.
  if (!is.null(dat$delay)) { # delay model
    odin_generate_delay(obj, dat)
  }

  nms <- vcapply(dat$eqs, function(x) x$lhs$name)
  for (x in dat$eqs[match(dat$order, nms)]) {
    if (identical(x$lhs$special, "dim")) {
      odin_generate_dim(x, obj, dat)
    } else if (isTRUE(x$rhs$delay)) {
      obj[[STAGE_TIME]]$add(delay[[x$rhs$group_delay]]$pop())
    } else if (x$lhs$type == "symbol") {
      odin_generate_symbol(x, obj, dat)
    } else if (x$lhs$type == "array") {
      odin_generate_array(x, obj, dat)
    } else {
      stop("Unhandled type")
    }
  }

  if (dat$variable_order$total_is_var) {
    obj$add_element(dat$variable_order$total_use, "int", FALSE)
    st <- STAGES[[dat$variable_order$total_stage]]
    obj[[st]]$add("%s = %s;",
                  obj$rewrite(dat$variable_order$total_use),
                  obj$rewrite(dat$variable_order$total))
  }
  obj$variable_size <- obj$rewrite(dat$variable_order$total_use)

  ## We're going to use this in a couple of places and it's kind of
  ## awkward.  In contrast with vars, which is known on entry to this
  ## function, types is collected by this function so needs to be
  ## written out at the end.
  obj$types <- do.call(rbind,
                       lapply(obj$types$get(),
                              as.data.frame, stringsAsFactors=FALSE))

  vars_len <- ifelse(dat$variable_order$is_array,
                     sprintf("dim_%s", dat$variable_order$order), "1")
  obj$vars <- data.frame(
    name=dat$variable_order$order,
    array=dat$variable_order$is_array,
    offset=vcapply(dat$variable_order$offset_use, obj$rewrite),
    length=vcapply(vars_len, obj$rewrite),
    stringsAsFactors=FALSE)

  obj
}

odin_generate_dim <- function(x, obj, dat) {
  ## TODO: put a check for this somewhere in parse.
  if (x$stage != STAGE_CONSTANT) {
    stop("This should never happen")
  }

  nm <- x$name
  nm_t <- x$lhs$name_target
  is_var <- nm_t %in% dat$vars
  nm_s <- if (is_var) paste0("initial_", nm_t) else nm_t
  st <- STAGES[[x$stage]]

  obj$add_element(nm_s, "double", TRUE)

  if (x$nd > 1L) {
    ## If allowed here, we'll generate:
    ##   dim_%s_%d % (nm, seq_along(nd))
    ##   dim_%s needs to be the product of these, and done last.
    ##   for nd 3 dim_%s_12 as dim_%s_1 * dim_%s_2, which is used
    ##     in matrix arithmetic
    stop("Multidimensional arrays not yet supported") # TODO
  } else {
    obj[[st]]$add("%s = %s;", obj$rewrite(nm), obj$rewrite(x$rhs$value))
  }

  if (is_var) {
    nm_offset <- paste0("offset_", nm_t)
    obj$add_element(nm_offset, "int", FALSE)
    obj[[st]]$add("%s = %s;", obj$rewrite(nm_offset),
                  obj$rewrite(dat$variable_order$offset[[nm_t]]))
  }

  obj[[st]]$add("%s = (double*) Calloc(%s, double);",
                obj$rewrite(nm_s), obj$rewrite(nm))
  obj$free$add("Free(%s);", obj$rewrite(nm_s))
}

odin_generate_symbol <- function(x, obj, dat) {
  nm <- x$name
  type <- if (nm %in% dat$index_vars) "int" else "double"
  st <- STAGES[[x$stage]]

  if (isTRUE(x$rhs$user)) {
    if (isTRUE(x$rhs$default)) {
      default <- obj$rewrite(x$rhs$value)
    } else {
      default <- if (type == "int") "NA_INTEGER" else "NA_REAL"
    }
    get_user <- sprintf("get_user_%s", type)
    obj$library_fns$add(get_user)
    value <- sprintf("%s(user, \"%s\", %s)", get_user, nm, default)
  } else {
    value <- obj$rewrite(x$rhs$value)
  }

  if (x$stage < STAGE_TIME) {
    obj$add_element(nm, type, FALSE)
    obj[[st]]$add("%s = %s;", obj$rewrite(nm), value)
  } else if (identical(x$lhs$special, "deriv")) {
    obj[[st]]$add("%s[%s] = %s;",
                  DSTATEDT,
                  dat$variable_order$offset_use[[x$lhs$name_target]],
                  value)
  } else {
    obj[[st]]$add("%s %s = %s;", type, nm, value)
  }
}

odin_generate_array <- function(x, obj, dat) {
  nm <- x$name
  st <- STAGES[[x$stage]]

  if (isTRUE(x$rhs$user)) {
    ## TODO - see issues.md: "user arrays"
    stop("User-supplied arrays not yet supported")
  }

  indent <- ""
  for (j in seq_along(x$lhs$index)) {
    xj <- x$lhs$index[[j]]
    is_range <- xj$is_range
    target <- xj$extent_max
    ## TODO: The index variables need sanitising so that no more
    ## than one of i,j,k is allowed; things like x[i,j] = z[i + j]
    ## are not allowed!
    for (k in seq_along(is_range)) {
      if (is_range[k]) {
        obj[[st]]$add("%sfor (int %s = %s; %s < %s; ++%s) {",
                      indent,
                      INDEX[[k]], minus1(xj$extent_min[[k]], obj$rewrite),
                      INDEX[[k]], obj$rewrite(xj$extent_max[[k]]),
                      INDEX[[k]])
        indent <- paste0("  ", indent)
        target[[k]] <- as.symbol(INDEX[[k]])
      } else if (INDEX[[k]] %in% x$rhs$depends$variables) {
        ## TODO: I need to get the index rhs depends back here to
        ## do this best (i.e., if the rhs does not depend on an
        ## index then don't bother adding the declaration here).
        ## As it is this will do this for *all* entries which is
        ## not ideal.
        if (!nzchar(indent)) {
          obj[[st]]$add("{")
          indent <- "  "
        }
        obj[[st]]$add("%sint %s = %s;", indent, INDEX[[k]],
                      minus1(xj$extent_max[[k]], obj$rewrite))
        target[[k]] <- as.symbol(INDEX[[k]])
      } else {
        target[[k]] <- xj$extent_max[[k]]
      }
    }
    target <- obj$rewrite(as.call(c(quote(`[`), as.symbol(nm), target)))
    value <- obj$rewrite(x$rhs$value[[j]])
    obj[[st]]$add("%s%s = %s;", indent, target, value)

    while (nzchar(indent)) {
      indent <- substr(indent, 3L, nchar(indent))
      obj[[st]]$add("%s}", indent)
    }
  }
}

odin_generate_delay <- function(obj, dat) {
  browser()

  dat$library_fns$add("lagvalue")
  ## NOTE: In the pointer creation we might need to return a little
  ## additional information about things like being a delay model or
  ## not.  Return a list?  Affects the template mostly.
  for (i in seq_along(dat$delay)) {
    delay_i <- dat$delay[[i]]
    delay_c <- collector()

    ## TODO: This can be relaxed soon, just requires more book-keeping.
    if (any(dat$variable_order$is_array[delay_i$extract])) {
      stop("Delay arrays not supported")
    }
    if (any(is_array[match(delay_i$order, nms)])) {
      stop("Delay dependency arrays not supported")
    }

    ## TODO: This one varies with things like the length of arrays;
    ## we'll be looking for
    ##   tmp <- names(which(dat$variable_order$is_array[delay_i$extract]))
    ##   paste(sprintf("dim_%s", tmp), collapse=" + ")
    ## added onto
    ##   length(delay_i$extract) -
    ##     sum(dat$variable_order$is_array[delay_i$extract])
    ##
    ## NOTE: There's some duplication here in terms of the size of
    ## various arrays.  That helps with some assumptions about how
    ## the array allocations and copying works.  It's possible that
    ## could be worked around with a #define but I don't think it's
    ## worth it at this point.  For now just accept the redundancy.
    ##
    ## NOTE: it would be *heaps* simpler to extract the entire
    ## structure here (create one vector of length `p->dim` and set
    ## it as `0..(p->dim-1)` but potentially slower as it will look
    ## up all varaibles (and most of the time we won't be interested
    ## in all).
    ##
    ## TODO: Consider in the case of a single delay dropping the _1
    ## and going with delay_idx, etc.
    ##
    ## TODO: The Calloc/Free calls here could move into contents if
    ## it took a stage argument.
    delay_i_len <- length(delay_i$extract)

    ## 1. delay_<i>_idx & dim_delay_<i>_idx; indices for deSolve
    delay_i_idx <- sprintf("delay_%d_idx", i)
    type_add(sprintf("dim_%s", delay_i_idx), "int", FALSE)
    type_add(delay_i_idx, "int", TRUE)
    obj[[STAGE_CONSTANT]]$add("%s->dim_%s = %d;",
                              name_pars, delay_i_idx, delay_i_len)
    obj[[STAGE_CONSTANT]]$add("%s->%s = (int*)Calloc(%s->dim_%s, int);",
                              name_pars, delay_i_idx, name_pars, delay_i_idx)
    free$add("Free(%s->%s);", name_pars, delay_i_idx)

    ## 2. delay_<i>_state & dim_delay_<i>_state; memory for deSolve
    ## (NOTE: this is unfortunate in the dim_ variable)
    delay_i_state <- sprintf("delay_%d_%s", i, STATE)
    type_add(sprintf("dim_%s", delay_i_state), "int", FALSE)
    type_add(delay_i_state, "double", TRUE)
    obj[[STAGE_CONSTANT]]$add("%s->dim_%s = %d;",
                              name_pars, delay_i_state, delay_i_len)
    obj[[STAGE_CONSTANT]]$add(
                           "%s->%s = (double*)Calloc(%s->dim_%s, double);",
                           name_pars, delay_i_state, name_pars, delay_i_state)
    delay_offset <-
      vcapply(dat$variable_order$offset_use[delay_i$extract], rewrite)
    ## TODO: If the offsets are stored in the structure, point at
    ## those instead?  Look for "offset_is_var"
    obj[[STAGE_CONSTANT]]$add(
                           "%s->%s[%d] = %s;",
                           name_pars, delay_i_idx,
                           seq_along(delay_offset) - 1L,
                           delay_offset)
    free$add("Free(%s->%s);", name_pars, delay_i_state)

    ## 3. Prepare output variables so we can push them up out of
    ## scope:
    delay_c$add("double %s;", delay_i$names)
    delay_c$add("{")

    ## TODO: Getting this correct is going to require that we can
    ## output the bits from the big loop+conditional on demand;
    ## that's going to be a challenge to get right, but will require
    ## some functionalisation.  If this approach fails I will
    ## backtrack and and refactor this mess first.

    ## 4. Pull things out of the lag value, but only if time is past
    ## where the lag is OK to work with.  That's going to look like:
    ## TODO: when working with arrays, some of these are *<x>.
    delay_c$add("  double %s;",
                paste(delay_i$extract, collapse=", "))
    ## TODO: delay times are going to matter a lot here.  This block
    ## actually wants running only when the delay is resolved.  So,
    ## need to interleave this in appropriately.
    delay_c$add("  double delay_%s = %s - %s;",
                TIME, TIME, obj$rewrite(delay_i$time))
    delay_c$add("  if (delay_%s <= %s->initial_%s) {",
                TIME, name_pars, TIME)
    delay_c$add("    %s = %s->initial_%s;",
                delay_i$extract, name_pars, delay_i$extract)
    delay_c$add("  } else {")
    ## TODO: These should be added to the lookup list and done with
    ## rewrite.
    delay_c$add("    lagvalue(delay_%s, %s->%s, %s->dim_%s, %s->%s);",
                TIME, name_pars, delay_i_idx, name_pars, delay_i_idx,
                name_pars, delay_i_state)
    ## Then dump out all the values.  TODO: when we allow arrays in
    ## here, then offsets will be required, and the initialisation
    ## looks a little different. For now this is a little easier
    ## though, because everything is a number!
    delay_c$add("    %s = %s->%s[%d];",
                delay_i$extract, name_pars, delay_i_state,
                seq_along(delay_i$extract) - 1L)
    delay_c$add("  }")

    ## Then we'll organise that whenever we hit a variable that is
    ## used in a delay statement we'll add it in here in the
    ## appropriate order.

    ## TODO: this will need a little more work for the array case;
    ## by then we'll really need the rhs writing stuff factored out.
    for (nm in delay_i$order) {
      delay_c$add("  double %s = %s;", nm,
                  obj$rewrite(dat$eqs[[match(nm, nms)]]$rhs$value))
    }
    for (nm in delay_i$names) {
      delay_c$add("  %s = %s;", nm,
                  obj$rewrite(dat$eqs[[match(nm, nms)]]$rhs$value_expr))
    }

    delay_c$add("}")
    delay[[i]] <- delay_c
  }
}

## TODO: Consider a different prefix for these as the functions really
## fall into two phases; global collection and output.  Below here is
## all output and does not modify obj.
odin_generate_order <- function(obj) {
  ret <- collector()
  ret$add("// Report back to R information on variable ordering")
  ret$add("// The reported information includes position and length of each")
  ret$add("// variable, from which offset, etc, can be worked out.")

  ret$add("SEXP %s_order(SEXP %s_ptr) {", obj$base, obj$base)
  ret$add("  %s *%s = %s_get_pointer(%s_ptr, 1);",
          obj$type_pars, obj$name_pars, obj$base, obj$base)
  ret$add("  SEXP %s_len = PROTECT(allocVector(INTSXP, %d));",
          STATE, length(dat$variable_order$offset))
  ret$add("  SEXP %s_names = PROTECT(allocVector(STRSXP, %d));",
          STATE, length(dat$variable_order$offset))

  i <- seq_len(nrow(obj[["vars"]])) - 1L
  ret$add("  INTEGER(%s_len)[%s] = %s;", STATE, i, obj[["vars"]]$length)
  ret$add("  SET_STRING_ELT(%s_names, %d, mkChar(\"%s\"));",
          STATE, i, obj[["vars"]]$name)
  ret$add("  setAttrib(%s_len, R_NamesSymbol, %s_names);", STATE, STATE)
  ret$add("  UNPROTECT(2);")
  ret$add("  return %s_len;", STATE)
  ret$add("}")
  ret$get()
}

odin_generate_contents <- function(obj) {
  types <- obj$types
  len <- nrow(types)

  rtype <- c(int="INTSXP", double="REALSXP")
  raccess <- c(int="INTEGER", double="REAL")

  ret <- collector()
  ret$add("// Translate all elements in the struct back to R")
  ret$add("// This will mostly be useful for debugging.")
  ret$add("SEXP %s_contents(SEXP %s_ptr) {", obj$base, obj$base)
  ret$add("  %s *%s = %s_get_pointer(%s_ptr, 1);",
          obj$type_pars, obj$name_pars, obj$base, obj$base)
  ret$add("  SEXP %s = PROTECT(allocVector(VECSXP, %d));",
          STATE, len)
  for (i in seq_len(len)) {
    name <- types$name[[i]]
    type <- types$type[[i]]
    if (types$array[[i]]) {
      if (grepl("^initial_", name)) {
        name_dim <- sub("^initial_", "dim_", name)
      } else {
        name_dim <- sprintf("dim_%s", name)
      }
      ret$add("  SET_VECTOR_ELT(%s, %d, allocVector(%s, %s));",
                   STATE, i - 1L, rtype[[type]], obj$rewrite(name_dim))
      ret$add("  memcpy(%s(VECTOR_ELT(%s, %d)), %s, %s * sizeof(%s));",
              raccess[[type]], STATE, i - 1L, obj$rewrite(name),
              obj$rewrite(name_dim), type)
    } else {
      type <- if (type == "int") "Integer" else "Real"
      ret$add("  SET_VECTOR_ELT(%s, %d, Scalar%s(%s));",
              STATE, i - 1L, type, obj$rewrite(name))
    }
  }

  ret$add("  SEXP %s_names = PROTECT(allocVector(STRSXP, %d));",
          STATE, len)
  ret$add('  SET_STRING_ELT(%s_names, %d, mkChar("%s"));',
          STATE, seq_len(len) - 1L, types$name)

  ret$add("  setAttrib(%s, R_NamesSymbol, %s_names);", STATE, STATE)
  ret$add("  UNPROTECT(2);")
  ret$add("  return %s;", STATE)
  ret$add("}")

  ret$get()
}

odin_generate_struct <- function(obj) {
  types <- obj$types
  type <- sprintf("%s_pars", obj$base)
  ret <- collector()
  ret$add("// Collect together all the parameters and transient memory")
  ret$add("// required to run the model in a struct.")
  ret$add("typedef struct %s {", type)
  ret$add("  %s %s%s;", types$type, ifelse(types$array, "*", ""), types$name)
  ret$add("} %s;", type)
  ret$add("// Global variable set on initmod, as per deSolve design")
  ret$add("static %s *%s;", type, obj$name_pars)
  ret$get()
}

odin_generate_finalize <- function(obj) {
  ret <- collector()
  ret$add("// Arrange to free all memory we have allocated")
  ret$add("// This is called by R automatically when the pointer is")
  ret$add("// garbage collected (i.e., when all objects holding the pointer")
  ret$add("// go out of scope")
  ret$add("void %s_finalize(SEXP %s_ptr) {", obj$base, obj$base)
  ret$add("  %s *%s = %s_get_pointer(%s_ptr, 0);",
          obj$type_pars, obj$name_pars, obj$base, obj$base)
  ret$add("  if (%s_ptr) {", obj$base)
  ret$add(indent(obj$free$get(), 4))
  ret$add("    Free(%s);", obj$name_pars)
  ret$add("    R_ClearExternalPtr(%s_ptr);", obj$base)
  ret$add("  }")
  ret$add("}")

  ## We need a declaration for this one.  However, if things get
  ## broken up into a header and nonheader file this will need
  ## injecting into the nonheader file I think.  For now it's fine.

  ret$get()
}

odin_generate_create <- function(obj) {
  ret <- collector()
  ret$add("// Create the pointer; this will establish the struct, allocate")
  ret$add("// memory for things that are constant size, and initialize")
  ret$add("// constant variables")
  ## See odin_generate_finalize(); we need to declare the finalizer here.
  ret$add("static void %s_finalize(SEXP %s_ptr);", obj$base, obj$base)
  ret$add("SEXP %s_create(SEXP user) {", obj$base)
  ret$add("  %s *%s = (%s*) Calloc(1, %s);",
          obj$type_pars, obj$name_pars, obj$type_pars, obj$type_pars)
  ret$add(indent(obj$constant$get(), 2))
  ret$add(
    "  SEXP %s_ptr = PROTECT(R_MakeExternalPtr(%s, R_NilValue, R_NilValue));",
    obj$base, obj$name_pars)
  ret$add("  R_RegisterCFinalizer(%s_ptr, %s_finalize);", obj$base, obj$base)
  ret$add("  UNPROTECT(1);")
  ret$add("  return %s_ptr;", obj$base)
  ret$add("}")
  ret$get()
}

## TODO: for %s_ptr, use odin_ptr (<base>_ptr) or use <obj$type_pars>_ptr?
## TODO: this will also take a user object.
odin_generate_initial <- function(obj) {
  ret <- collector()
  ret$add("SEXP %s_initialise(SEXP %s_ptr, SEXP %s_ptr) {",
          obj$base, obj$base, TIME)
  ret$add("  const double %s = REAL(%s_ptr)[0];", TIME, TIME)
  ret$add("  %s *%s = %s_get_pointer(%s_ptr, 1);",
          obj$type_pars, obj$name_pars, obj$base, obj$base)
  ret$add(as.character(indent(obj$initial$get(), 2)))

  ## It's possible this bit should be factored out into a separate function?
  ret$add("  SEXP %s = PROTECT(allocVector(REALSXP, %s));",
          STATE, obj$variable_size)
  copy <- character(nrow(obj[["vars"]]))
  i <- obj[["vars"]]$array
  nm_initial <- vcapply(sprintf("initial_%s", obj[["vars"]]$name), obj$rewrite)
  copy[i] <- sprintf("  memcpy(REAL(%s) + %s, %s, %s * sizeof(double));",
                     STATE, obj[["vars"]]$offset[i], nm_initial[i],
                     obj[["vars"]]$length[i])
  copy[!i] <- sprintf("  REAL(%s)[%s] = %s;",
                      STATE, obj[["vars"]]$offset[!i], nm_initial[!i])
  ret$add(copy)
  ret$add("  UNPROTECT(1);")
  ret$add("  return %s;", STATE)
  ret$add("}")
  ret$get()
}

## OK, this one is slightly complicated because there are *three*
## forms of the derivative function.  The base one (that this does)
## returns void and takes a pointer.
odin_generate_deriv <- function(obj) {
  vars <- obj[["vars"]]
  ret <- collector()

  ret$add("void %s_deriv(%s *%s, double %s, double *%s, double *%s) {",
          obj$base, obj$type_pars, obj$name_pars, TIME, STATE, DSTATEDT)

  ## We always need to pull variables out of the state vector, and set
  ## up pointers for array derivatives.  This happens at the beginning
  ## of the derivative calculations.
  ret$add("  double %s%s = %s + %s;",
               ifelse(vars$array, "*", ""), vars$name, STATE, vars$offset)
  if (any(vars$array)) {
    ret$add("  double *deriv_%s = %s + %s;",
                 vars$name[vars$array], DSTATEDT, vars$offset[vars$array])
  }

  ret$add(indent(obj$time$get(), 2))
  ret$add("}")
  ret$get()
}

odin_generate_library_fns <- function(obj) {
  dat <- read_library()
  fns <- obj$library_fns$get()

  if (any(grepl("^get_user_", fns))) {
    fns <- c(fns, "get_list_element")
  }

  list(declarations=unname(dat$declarations[fns]),
       definitions=unname(dat$definitions[fns]))
}

## NOTE: This does violate the idea that these leave obj unmodified;
## this adds a declaration for the get_pointer function.
odin_generate_support <- function(obj) {
  ret <- collector()
  obj$declarations$add("%s* %s_get_pointer(SEXP %s_ptr, int closed_error);",
                       obj$type_pars, obj$base, obj$base)
  ret$add("%s* %s_get_pointer(SEXP %s_ptr, int closed_error) {",
          obj$type_pars, obj$base, obj$base)
  ret$add("  %s *%s = NULL;", obj$type_pars, obj$name_pars)
  ret$add("  if (TYPEOF(%s_ptr) != EXTPTRSXP) {", obj$base)
  ret$add('    Rf_error("Expected an external pointer");')
  ret$add("  }")
  ret$add("  %s = (%s*) R_ExternalPtrAddr(%s_ptr);",
          obj$name_pars, obj$type_pars, obj$base)
  ret$add("  if (!%s && closed_error) {", obj$name_pars)
  ret$add('    Rf_error("Pointer has been invalidated");')
  ret$add("  }")
  ret$add("  return %s;", obj$name_pars)
  ret$add("}")
  ret$get()
}

odin_generate_deriv_r <- function(obj) {
  ret <- collector()
  ret$add("SEXP r_%s_deriv(SEXP %s_ptr, SEXP %s, SEXP %s) {",
          obj$base, obj$base, TIME, STATE)
  ret$add("  SEXP %s = PROTECT(allocVector(REALSXP, LENGTH(%s)));",
          DSTATEDT, STATE)
  ret$add("  // NOTE: this assigns to the deSolve-required global variable")
  ret$add("  %s *%s = %s_get_pointer(%s_ptr, 1);",
          obj$type_pars, obj$name_pars, obj$base, obj$base)
  ret$add("  %s_deriv(%s, REAL(%s)[0], REAL(%s), REAL(%s));",
          obj$base, obj$name_pars, TIME, STATE, DSTATEDT)
  ret$add("  UNPROTECT(1);")
  ret$add("  return %s;", DSTATEDT)
  ret$add("}")
  ret$get()
}

odin_generate_desolve <- function(obj) {
  ret <- collector()
  ret$add("// deSolve interface")
  ret$add("void %s_ds_initmod(void(* odeparms) (int *, double *)) {",
          obj$base)
  ## TODO: this might change to something that uses the static trick
  ## here.
  ret$add('  DL_FUNC get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");')
  ret$add("  %s = %s_get_pointer(get_deSolve_gparms(), 1);",
          obj$name_pars, obj$base)
  ret$add("}")
  ret$add("void %s_ds_derivs(int *neq, double *t, double *%s,", obj$base, STATE)
  ret$add("%sdouble *%s, double *yout, int *np) {",
          strrep(nchar(obj$base) + 15L), DSTATEDT)
  ret$add("  %s_deriv(%s, *%s, %s, %s);",
          obj$base, obj$name_pars, TIME, STATE, DSTATEDT)
  ret$add("}")
  ret$get()
}

## Read a bunch of library functions.  The format here is important.
read_library <- function() {
  d <- readLines(system.file("library.c", package="odin"))
  re <- "^[[:alnum:]]+ ([[:alnum:]_]+)(.+) \\{$"
  i <- grep(re, d)
  j <- grep("^}$", d)
  stopifnot(length(i) == length(j))

  name <- sub(re, "\\1", d[i])
  decl <- setNames(sub(" \\{$", ";", d[i]), name)
  defn <- setNames(vcapply(seq_along(i), function(k)
    paste(d[i[[k]]:j[[k]]], collapse="\n")), name)
  list(declarations=decl, definitions=defn)
}
