odin_generate <- function(dat, base="odin", dest=tempfile()) {
  obj <- odin_generate_loop(dat, base)
  ## This one is special because it fills up declarations; it miust be
  ## run first.
  support <- odin_generate_support(obj)
  library_fns <- odin_generate_library_fns(obj)
  declarations <- c(obj$declarations$get(), library_fns$declarations)

  header <- c("// This is automatically generated by odin.",
              "// Do not edit by hand as changes will be lost.",
              "#include <R.h>",
              "#include <Rinternals.h>",
              "#include <R_ext/Rdynload.h>")

  ## Then attempt to make some sense out of the things that we have
  ## collected:
  ret <- list(header,
              odin_generate_struct(obj),
              declarations,
              create=odin_generate_create(obj),
              odin_generate_finalize(obj),
              odin_generate_initial(obj),
              deriv=odin_generate_deriv(obj),
              odin_generate_deriv_r(obj),
              odin_generate_contents(obj),
              odin_generate_order(obj),
              odin_generate_output_order(obj),
              odin_generate_desolve(obj),
              support,
              library_fns$definitions)

  txt <- paste(vcapply(ret, paste, collapse="\n"),
               collapse="\n\n")
  writeLines(txt, dest)
  dest
}

## What we are going to write here is a little bit of (fairly nasty)
## reference-style code that will help generate the inteface.  The
## simplest way of doing this might be to generate a small list of
## types that we can reference everywhere.  But that might just be
## more complicated than it needs to be?
odin_generate_object <- function(base, dat) {
  self <- list(base=base)

  self$name_pars <- sprintf("%s_p", base)
  self$type_pars <- sprintf("%s_pars", base)

  ## This is the set of variables we know to be *ours*.
  lookup <- collector()

  ## Rewrite based on that.
  self$rewrite <- function(x) {
    rewrite_c(x, self$name_pars, lookup$get(), INDEX)
  }

  ## Type information will generate a bunch of extra things, so
  ## process that later for simplicity:
  self$types <- collector_list()

  ## Create, initialise, derivatives
  self$constant <- collector()
  self$initial <- collector()
  self$time <- collector()

  self$free <- collector()

  ## Keep track of which library functions we need.  I'll keep those
  ## elsewhere and select them based on name.
  self$library_fns <- collector()
  self$declarations <- collector()

  self$add_element <- function(name, type, array) {
    if (array) {
      name_dim <- array_dim_name(name, FALSE)
      if (!is.null(name_dim)) {
        Recall(name_dim, "int", FALSE)
      }
    }
    self$types$add(list(name=name, type=type, array=array))
    lookup$add(name)
  }
  self
}

## TODO: Disallow '<base>_' as a name; otherwise potential for
## collision, so probably set that in the DSL rather than here.
odin_generate_loop <- function(dat, base) {
  obj <- odin_generate_object(base, dat)

  ## Set up initial time so we can refer to it later.  Not all models
  ## make use of this, but it seems worth adding (and doesn't take
  ## that much space).  Delay models will make extensive use of this.
  ## We could omit this for any non-delay model perhaps?
  ##
  ## TODO: support general RHS rewriting of initial(x) -> initial_x
  ## combined with parse-time checking of valid x.
  obj$add_element(sprintf("initial_%s", TIME), "double", FALSE)

  ## We'll always need this.
  obj$library_fns$add("get_ds_pars")
  fns <- unique(unlist(lapply(dat$eqs, function(x) x$depends$functions)))
  if ("sum" %in% fns) {
    obj$library_fns$add("odin_sum")
  }
  if (dat$has_delay) {
    obj$library_fns$add("lagvalue")
  }

  nms <- names(dat$eqs)
  for (x in dat$eqs) {
    if (identical(x$lhs$special, "dim")) {
      odin_generate_dim(x, obj, dat)
    } else if (isTRUE(x$rhs$delay)) {
      odin_generate_delay(x, obj, dat)
    } else if (x$lhs$type == "symbol") {
      odin_generate_symbol(x, obj, dat)
    } else if (x$lhs$type == "array") {
      odin_generate_array(x, obj, dat)
    } else {
      stop("Unhandled type")
    }
  }

  if (dat$variable_order$total_is_var) {
    obj$add_element(dat$variable_order$total_use, "int", FALSE)
    st <- STAGES[[dat$variable_order$total_stage]]
    obj[[st]]$add("%s = %s;",
                  obj$rewrite(dat$variable_order$total_use),
                  obj$rewrite(dat$variable_order$total))
  }
  obj$variable_size <- obj$rewrite(dat$variable_order$total_use)

  if (dat$has_output) {
    if (dat$output_order$total_is_var) {
      obj$add_element(dat$output_order$total_use, "int", FALSE)
      st <- STAGES[[dat$output_order$total_stage]]
      obj[[st]]$add("%s = %s;",
                    obj$rewrite(dat$output_order$total_use),
                    obj$rewrite(dat$output_order$total))
    }
    obj$output_size <- obj$rewrite(dat$output_order$total_use)
  }

  ## We're going to use this in a couple of places and it's kind of
  ## awkward.  In contrast with vars, which is known on entry to this
  ## function, types is collected by this function so needs to be
  ## written out at the end.
  obj$types <- do.call(rbind,
                       lapply(obj$types$get(),
                              as.data.frame, stringsAsFactors=FALSE))

  vars_len <- rep_len("1", length(dat$variable_order$is_array))
  vars_len[dat$variable_order$is_array] <-
    vcapply(dat$variable_order$order[dat$variable_order$is_array],
            array_dim_name, TRUE)
  obj$vars <- data.frame(
    name=dat$variable_order$order,
    array=dat$variable_order$is_array,
    offset=vcapply(dat$variable_order$offset_use, obj$rewrite),
    length=vcapply(vars_len, obj$rewrite),
    stringsAsFactors=FALSE)

  if (dat$has_output) {
    output_len <- rep_len("1", length(dat$output_order$is_array))
    output_len[dat$output_order$is_array] <-
      vcapply(dat$output_order$order[dat$output_order$is_array],
              array_dim_name, TRUE)
    obj$output <- data.frame(
      name=dat$output_order$order,
      array=dat$output_order$is_array,
      offset=vcapply(dat$output_order$offset_use, obj$rewrite),
      length=vcapply(output_len, obj$rewrite),
      stringsAsFactors=FALSE)
  }

  obj
}

odin_generate_dim <- function(x, obj, dat) {
  ## TODO: put a check for this somewhere in parse.
  if (x$stage != STAGE_CONSTANT) {
    stop("This should never happen")
  }

  nm <- x$name
  nm_t <- x$lhs$name_target
  is_var <- nm_t %in% dat$vars
  nm_s <- if (is_var) paste0("initial_", nm_t) else nm_t
  st <- STAGES[[x$stage]]

  obj$add_element(nm_s, "double", TRUE)

  if (x$nd > 1L) {
    ## If allowed here, we'll generate:
    ##   dim_%s_%d % (nm, seq_along(nd))
    ##   dim_%s needs to be the product of these, and done last.
    ##   for nd 3 dim_%s_12 as dim_%s_1 * dim_%s_2, which is used
    ##     in matrix arithmetic
    stop("Multidimensional arrays not yet supported") # TODO
  } else {
    obj[[st]]$add("%s = %s;", obj$rewrite(nm), obj$rewrite(x$rhs$value))
  }

  if (is_var) {
    nm_offset <- paste0("offset_", nm_t)
    obj$add_element(nm_offset, "int", FALSE)
    obj[[st]]$add("%s = %s;", obj$rewrite(nm_offset),
                  obj$rewrite(dat$variable_order$offset[[nm_t]]))
  }

  obj[[st]]$add("%s = (double*) Calloc(%s, double);",
                obj$rewrite(nm_s), obj$rewrite(nm))
  obj$free$add("Free(%s);", obj$rewrite(nm_s))
}

odin_generate_symbol <- function(x, obj, dat) {
  nm <- x$name
  type <- if (nm %in% dat$index_vars) "int" else "double"
  st <- STAGES[[x$stage]]

  if (isTRUE(x$rhs$user)) {
    ## TODO: Is it checked somewhere that none of these end up in TIME?
    if (isTRUE(x$rhs$default)) {
      default <- obj$rewrite(x$rhs$value)
    } else {
      default <- if (type == "int") "NA_INTEGER" else "NA_REAL"
    }
    get_user <- sprintf("get_user_%s", type)
    obj$library_fns$add(get_user)
    value <- sprintf("%s(user, \"%s\", %s)", get_user, nm, default)
  } else {
    value <- obj$rewrite(x$rhs$value)
  }

  if (x$stage < STAGE_TIME) {
    obj$add_element(nm, type, FALSE)
    obj[[st]]$add("%s = %s;", obj$rewrite(nm), value)
  } else if (identical(x$lhs$special, "deriv")) {
    obj[[st]]$add("%s[%s] = %s;",
                  DSTATEDT,
                  dat$variable_order$offset_use[[x$lhs$name_target]],
                  value)
  } else if (identical(x$lhs$special, "output")) {
    obj[[st]]$add("%s[%s] = %s;",
                  OUTPUT, dat$output_order$offset_use[[nm]], value)
  } else {
    obj[[st]]$add("%s %s = %s;", type, nm, value)
  }
}

odin_generate_array <- function(x, obj, dat) {
  nm <- x$name
  st <- STAGES[[x$stage]]

  if (isTRUE(x$rhs$user)) {
    ## TODO - see issues.md: "user arrays"
    stop("User-supplied arrays not yet supported")
  }

  indent <- ""
  for (j in seq_along(x$lhs$index)) {
    xj <- x$lhs$index[[j]]
    is_range <- xj$is_range
    target <- xj$extent_max
    ## TODO: The index variables need sanitising so that no more
    ## than one of i,j,k is allowed; things like x[i,j] = z[i + j]
    ## are not allowed!
    for (k in seq_along(is_range)) {
      if (is_range[k]) {
        obj[[st]]$add("%sfor (int %s = %s; %s < %s; ++%s) {",
                      indent,
                      INDEX[[k]], minus1(xj$extent_min[[k]], obj$rewrite),
                      INDEX[[k]], obj$rewrite(xj$extent_max[[k]]),
                      INDEX[[k]])
        indent <- paste0("  ", indent)
        target[[k]] <- as.symbol(INDEX[[k]])
      } else if (INDEX[[k]] %in% x$rhs$depends$variables) {
        ## TODO: I need to get the index rhs depends back here to
        ## do this best (i.e., if the rhs does not depend on an
        ## index then don't bother adding the declaration here).
        ## As it is this will do this for *all* entries which is
        ## not ideal.
        if (!nzchar(indent)) {
          obj[[st]]$add("{")
          indent <- "  "
        }
        obj[[st]]$add("%sint %s = %s;", indent, INDEX[[k]],
                      minus1(xj$extent_max[[k]], obj$rewrite))
        target[[k]] <- as.symbol(INDEX[[k]])
      } else {
        target[[k]] <- xj$extent_max[[k]]
      }
    }
    target <- obj$rewrite(as.call(c(quote(`[`), as.symbol(nm), target)))
    value <- obj$rewrite(x$rhs$value[[j]])
    obj[[st]]$add("%s%s = %s;", indent, target, value)

    while (nzchar(indent)) {
      indent <- substr(indent, 3L, nchar(indent))
      obj[[st]]$add("%s}", indent)
    }
  }
}

odin_generate_delay <- function(x, obj, dat) {
  ## TODO: This can be relaxed soon, just requires more
  ## book-keeping, and a bunch of testing.
  if (any(dat$variable_order$is_array[x$delay$extract])) {
    stop("Delay arrays not supported")
  }
  dep_is_array <- vcapply(dat$eqs[c(x$name, x$delay$order)],
                          function(x) x$lhs$type) == "array"
  if (any(dep_is_array)) {
    stop("Delay dependency arrays not supported")
  }

  ## TODO: delay_i_len varies if there are arrays; it becomes a new
  ## variable with a stage equal to the max of all the array sizes
  ## used.  This is a lot like the situation with computing 'dim'.
  ##
  ## we'll be looking for
  ##   tmp <- names(which(dat$variable_order$is_array[delay_i$extract]))
  ##   paste(array_dim_name(tmp), collapse=" + ")
  ## added onto
  ##   length(delay_i$extract) -
  ##     sum(dat$variable_order$is_array[delay_i$extract])
  ##
  ## NOTE: There's some duplication here in terms of the size of
  ## various arrays.  That helps with some assumptions about how
  ## the array allocations and copying works.  It's possible that
  ## could be worked around with a #define but I don't think it's
  ## worth it at this point.  For now just accept the redundancy.
  ##
  ## NOTE: it would be *heaps* simpler to extract the entire
  ## structure here (create one vector of length `p->dim` and set
  ## it as `0..(p->dim-1)` but potentially slower as it will look
  ## up all varaibles (and most of the time we won't be interested
  ## in all).
  ##
  ## TODO: Consider in the case of a single delay dropping the _1
  ## and going with delay_idx, etc.
  ##
  ## TODO: The Calloc/Free calls here could move into contents if
  ## it took a stage argument.
  delay_len <- length(x$delay$extract)

  ## The options for naming are to use a series of indices (e.g., 1,
  ## 2, 3) or name things after the variables that are being delayed
  ## (delay_1_idx vs delay_lag_inf_idx, delay_1_state vs
  ## delay_lag_inf_state).  I think that the latter is probably nicer.
  delay_idx <- sprintf("delay_%s_idx", x$name)
  delay_state <- sprintf("delay_%s_state", x$name)
  delay_dim <- array_dim_name(delay_idx)
  delay_time <- "delay_time"

  ## If there are any arrays here we'll need to organise offsets.
  ## Rather than store the full offset vector I'll do this one by hand
  ## I think and let the compiler take care of it?  Getting this right
  ## will require a good test.  It's possible that this can be done
  ## with an accumulating variable as we'll need to get lengths here
  ## anyway.

  ## TODO: If using arrays it's possible that the size will vary.  If
  ## that's the case then this needs to be done very carefully; we
  ## must come _after_ the arrays have been declared in the order (so
  ## add a few more dependencies in parse) and the stage needs to be
  ## the max of those.
  st <- STAGES[STAGE_CONSTANT]

  obj$add_element(delay_idx, "int", TRUE)
  obj[[st]]$add("%s = %d;", obj$rewrite(delay_dim), delay_len)
  obj[[st]]$add("%s = (int*) Calloc(%s, int);",
                obj$rewrite(delay_idx), obj$rewrite(delay_dim))
  obj$free$add("Free(%s);", obj$rewrite(delay_idx))

  obj$add_element(delay_state, "double", TRUE)
  obj[[st]]$add("%s = (double*) Calloc(%s, double);",
                obj$rewrite(delay_state), obj$rewrite(delay_dim))
  obj$free$add("Free(%s);", obj$rewrite(delay_state))

  ## TODO: This needs more work for the array case because we pull
  ## whole arrays out.  So there will be loops in here.
  delay_offset <- dat$variable_order$offset_use[x$delay$extract]
  obj[[st]]$add("%s[%d] = %s;",
                obj$rewrite(delay_idx), seq_along(delay_offset) - 1L,
                vcapply(delay_offset, obj$rewrite))

  ## Next, prepare output variables so we can push them up out of
  ## scope (TODO: for arrays, this would be '*%s = %s', name,
  ## rewrite(name)).
  st <- STAGES[STAGE_TIME]
  obj[[st]]$add("double %s;", x$name)
  obj[[st]]$add("{")

  ## 4. Pull things out of the lag value, but only if time is past
  ## where the lag is OK to work with.  That's going to look like:
  ## TODO: when working with arrays, some of these are *<x>.
  obj[[st]]$add("  double %s;",
                paste(x$delay$extract, collapse=", "))

  ## TODO: if time is used in the time calculation it will need
  ## rewriting.
  obj[[st]]$add("  const double delay_%s = %s - %s;",
                TIME, TIME, obj$rewrite(x$delay$time))
  obj[[st]]$add("  if (delay_%s <= %s) {",
                TIME, obj$rewrite(sprintf("initial_%s", TIME)))
  obj[[st]]$add("    %s = %s;",
                x$delay$extract,
                vcapply(sprintf("initial_%s", x$delay$extract),
                        obj$rewrite, USE.NAMES=FALSE))
  obj[[st]]$add("  } else {")
  obj[[st]]$add("    lagvalue(delay_%s, %s, %s, %s);",
                TIME,
                obj$rewrite(delay_idx),
                obj$rewrite(delay_dim),
                obj$rewrite(delay_state))
  obj[[st]]$add("    %s = %s[%d];",
                x$delay$extract, obj$rewrite(delay_state),
                seq_along(x$delay$extract) - 1L)
  obj[[st]]$add("  }")

  ## Then we'll organise that whenever we hit a variable that is used
  ## in a delay statement we'll add it in here in the appropriate
  ## order.

  ## TODO: this will need a little more work for the array case; by
  ## then we'll really need the rhs writing stuff factored out.
  ## Getting that correct is going to require tweaks to things like
  ## odin_generate_symbol because we'd want to dump them into a
  ## temporary holding pen.  For the symbol case it's so easy that we
  ## can largely ignore it I think.
  for (nm in x$delay$order) {
    obj[[st]]$add("  double %s = %s;", nm,
                  obj$rewrite(dat$eqs[[nm]]$rhs$value))
  }
  obj[[st]]$add("  %s = %s;", x$name, obj$rewrite(x$rhs$value_expr))
  obj[[st]]$add("}")
}

## TODO: Consider a different prefix for these as the functions really
## fall into two phases; global collection and output.  Below here is
## all output and does not modify obj.
odin_generate_order <- function(obj) {
  ret <- collector()
  ret$add("// Report back to R information on variable ordering")
  ret$add("// The reported information includes position and length of each")
  ret$add("// variable, from which offset, etc, can be worked out.")

  ret$add("SEXP %s_order(SEXP %s_ptr) {", obj$base, obj$base)
  ret$add("  %s *%s = %s_get_pointer(%s_ptr, 1);",
          obj$type_pars, obj$name_pars, obj$base, obj$base)
  ret$add("  SEXP %s_len = PROTECT(allocVector(INTSXP, %d));",
          STATE, nrow(obj[["vars"]]))
  ret$add("  SEXP %s_names = PROTECT(allocVector(STRSXP, %d));",
          STATE, nrow(obj[["vars"]]))

  i <- seq_len(nrow(obj[["vars"]])) - 1L
  ret$add("  INTEGER(%s_len)[%s] = %s;", STATE, i, obj[["vars"]]$length)
  ret$add("  SET_STRING_ELT(%s_names, %d, mkChar(\"%s\"));",
          STATE, i, obj[["vars"]]$name)
  ret$add("  setAttrib(%s_len, R_NamesSymbol, %s_names);", STATE, STATE)
  ret$add("  UNPROTECT(2);")
  ret$add("  return %s_len;", STATE)
  ret$add("}")
  ret$get()
}

odin_generate_output_order <- function(obj) {
  ret <- collector()
  ret$add("// Report back to R information on output variable ordering")
  ret$add("// Like the variable order above, but for any output vars")
  ret$add("// If no output variables are used, return an R NULL")
  ret$add("SEXP %s_output_order(SEXP %s_ptr) {", obj$base, obj$base)
  if (is.null(obj[["output"]])) {
    ret$add("  return R_NilValue;", STATE)
  } else {
    ret$add("  %s *%s = %s_get_pointer(%s_ptr, 1);",
            obj$type_pars, obj$name_pars, obj$base, obj$base)
    ret$add("  SEXP %s_len = PROTECT(allocVector(INTSXP, %d));",
            STATE, nrow(obj[["output"]]))
    ret$add("  SEXP %s_names = PROTECT(allocVector(STRSXP, %d));",
            STATE, nrow(obj[["output"]]))
    i <- seq_len(nrow(obj[["output"]])) - 1L
    ret$add("  INTEGER(%s_len)[%s] = %s;", STATE, i, obj[["output"]]$length)
    ret$add("  SET_STRING_ELT(%s_names, %d, mkChar(\"%s\"));",
            STATE, i, obj[["output"]]$name)
    ret$add("  setAttrib(%s_len, R_NamesSymbol, %s_names);", STATE, STATE)
    ret$add("  UNPROTECT(2);")
    ret$add("  return %s_len;", STATE)
  }
  ret$add("}")
  ret$get()
}

odin_generate_contents <- function(obj) {
  types <- obj$types
  len <- nrow(types)

  rtype <- c(int="INTSXP", double="REALSXP")
  raccess <- c(int="INTEGER", double="REAL")

  ret <- collector()
  ret$add("// Translate all elements in the struct back to R")
  ret$add("// This will mostly be useful for debugging.")
  ret$add("SEXP %s_contents(SEXP %s_ptr) {", obj$base, obj$base)
  ret$add("  %s *%s = %s_get_pointer(%s_ptr, 1);",
          obj$type_pars, obj$name_pars, obj$base, obj$base)
  ret$add("  SEXP %s = PROTECT(allocVector(VECSXP, %d));",
          STATE, len)
  for (i in seq_len(len)) {
    name <- types$name[[i]]
    type <- types$type[[i]]
    if (types$array[[i]]) {
      name_dim <- array_dim_name(name)
      ret$add("  SET_VECTOR_ELT(%s, %d, allocVector(%s, %s));",
                   STATE, i - 1L, rtype[[type]], obj$rewrite(name_dim))
      ret$add("  memcpy(%s(VECTOR_ELT(%s, %d)), %s, %s * sizeof(%s));",
              raccess[[type]], STATE, i - 1L, obj$rewrite(name),
              obj$rewrite(name_dim), type)
    } else {
      type <- if (type == "int") "Integer" else "Real"
      ret$add("  SET_VECTOR_ELT(%s, %d, Scalar%s(%s));",
              STATE, i - 1L, type, obj$rewrite(name))
    }
  }

  ret$add("  SEXP %s_names = PROTECT(allocVector(STRSXP, %d));",
          STATE, len)
  ret$add('  SET_STRING_ELT(%s_names, %d, mkChar("%s"));',
          STATE, seq_len(len) - 1L, types$name)

  ret$add("  setAttrib(%s, R_NamesSymbol, %s_names);", STATE, STATE)
  ret$add("  UNPROTECT(2);")
  ret$add("  return %s;", STATE)
  ret$add("}")

  ret$get()
}

odin_generate_struct <- function(obj) {
  types <- obj$types
  type <- sprintf("%s_pars", obj$base)
  ret <- collector()
  ret$add("// Collect together all the parameters and transient memory")
  ret$add("// required to run the model in a struct.")
  ret$add("typedef struct %s {", type)
  ret$add("  %s %s%s;", types$type, ifelse(types$array, "*", ""), types$name)
  ret$add("} %s;", type)
  ret$add("// Global variable set on initmod, as per deSolve design")
  ret$add("static %s *%s;", type, obj$name_pars)
  ret$get()
}

odin_generate_finalize <- function(obj) {
  ret <- collector()
  ret$add("// Arrange to free all memory we have allocated")
  ret$add("// This is called by R automatically when the pointer is")
  ret$add("// garbage collected (i.e., when all objects holding the pointer")
  ret$add("// go out of scope")
  ret$add("void %s_finalize(SEXP %s_ptr) {", obj$base, obj$base)
  ret$add("  %s *%s = %s_get_pointer(%s_ptr, 0);",
          obj$type_pars, obj$name_pars, obj$base, obj$base)
  ret$add("  if (%s_ptr) {", obj$base)
  free <- obj$free$get()
  if (length(free) > 0L) {
    ret$add(indent(free, 4))
  }
  ret$add("    Free(%s);", obj$name_pars)
  ret$add("    R_ClearExternalPtr(%s_ptr);", obj$base)
  ret$add("  }")
  ret$add("}")

  ## We need a declaration for this one.  However, if things get
  ## broken up into a header and nonheader file this will need
  ## injecting into the nonheader file I think.  For now it's fine.

  ret$get()
}

odin_generate_create <- function(obj) {
  ret <- collector()
  ret$add("// Create the pointer; this will establish the struct, allocate")
  ret$add("// memory for things that are constant size, and initialize")
  ret$add("// constant variables")
  ## See odin_generate_finalize(); we need to declare the finalizer here.
  ret$add("static void %s_finalize(SEXP %s_ptr);", obj$base, obj$base)
  ret$add("SEXP %s_create(SEXP user) {", obj$base)
  ret$add("  %s *%s = (%s*) Calloc(1, %s);",
          obj$type_pars, obj$name_pars, obj$type_pars, obj$type_pars)
  ret$add(indent(obj$constant$get(), 2))
  ret$add(
    "  SEXP %s_ptr = PROTECT(R_MakeExternalPtr(%s, R_NilValue, R_NilValue));",
    obj$base, obj$name_pars)
  ret$add("  R_RegisterCFinalizer(%s_ptr, %s_finalize);", obj$base, obj$base)
  ret$add("  UNPROTECT(1);")
  ret$add("  return %s_ptr;", obj$base)
  ret$add("}")
  ret$get()
}

## TODO: for %s_ptr, use odin_ptr (<base>_ptr) or use <obj$type_pars>_ptr?
## TODO: this will also take a user object.
odin_generate_initial <- function(obj) {
  ret <- collector()
  ret$add("SEXP %s_initialise(SEXP %s_ptr, SEXP %s_ptr) {",
          obj$base, obj$base, TIME)
  ret$add("  const double %s = REAL(%s_ptr)[0];", TIME, TIME)
  ret$add("  %s *%s = %s_get_pointer(%s_ptr, 1);",
          obj$type_pars, obj$name_pars, obj$base, obj$base)
  ret$add(as.character(indent(obj$initial$get(), 2)))

  ## It's possible this bit should be factored out into a separate function?
  ret$add("  SEXP %s = PROTECT(allocVector(REALSXP, %s));",
          STATE, obj$variable_size)
  copy <- character(nrow(obj[["vars"]]))
  i <- obj[["vars"]]$array
  nm_initial <- vcapply(sprintf("initial_%s", obj[["vars"]]$name), obj$rewrite)
  copy[i] <- sprintf("  memcpy(REAL(%s) + %s, %s, %s * sizeof(double));",
                     STATE, obj[["vars"]]$offset[i], nm_initial[i],
                     obj[["vars"]]$length[i])
  copy[!i] <- sprintf("  REAL(%s)[%s] = %s;",
                      STATE, obj[["vars"]]$offset[!i], nm_initial[!i])
  ret$add(copy)
  if (!is.null(obj[["output"]])) {
    ret$add('  setAttrib(%s, install("%s_len"), ScalarInteger(%s));',
            STATE, OUTPUT, obj$output_size)
  }
  ret$add("  UNPROTECT(1);")
  ret$add("  return %s;", STATE)
  ret$add("}")
  ret$get()
}

## OK, this one is slightly complicated because there are *three*
## forms of the derivative function.  The base one (that this does)
## returns void and takes a pointer.
odin_generate_deriv <- function(obj) {
  vars <- obj[["vars"]]
  ret <- collector()

  ret$add(
    "void %s_deriv(%s *%s, double %s, double *%s, double *%s, double *%s) {",
    obj$base, obj$type_pars, obj$name_pars, TIME, STATE, DSTATEDT, OUTPUT)

  ## We always need to pull variables out of the state vector, and set
  ## up pointers for array derivatives.  This happens at the beginning
  ## of the derivative calculations.
  if (!any(vars$array)) {
    ret$add("  double %s = %s[%s];",
            vars$name[!vars$array], STATE, vars$offset[!vars$array])
  }
  if (any(vars$array)) {
    ret$add("  double *%s = %s + %s;",
            vars$name[vars$array], STATE, vars$offset[vars$array])
    ret$add("  double *deriv_%s = %s + %s;",
            vars$name[vars$array], DSTATEDT, vars$offset[vars$array])
  }
  if (any(obj$output$array)) {
    ret$add("  double *output_%s = %s + %s;",
            obj$output$name[obj$output$array], OUTPUT,
            obj$output$offset[obj$output$array])
  }

  ret$add(indent(obj$time$get(), 2))
  ret$add("}")
  ret$get()
}

odin_generate_library_fns <- function(obj) {
  dat <- read_library()
  fns <- obj$library_fns$get()
  if (any(grepl("^get_user_", fns))) {
    fns <- c(fns, "get_list_element")
  }
  fns <- unique(fns)
  list(declarations=unname(dat$declarations[fns]),
       definitions=unname(dat$definitions[fns]))
}

## NOTE: This does violate the idea that these leave obj unmodified;
## this adds a declaration for the get_pointer function.
odin_generate_support <- function(obj) {
  ret <- collector()
  obj$declarations$add("%s* %s_get_pointer(SEXP %s_ptr, int closed_error);",
                       obj$type_pars, obj$base, obj$base)
  ret$add("%s* %s_get_pointer(SEXP %s_ptr, int closed_error) {",
          obj$type_pars, obj$base, obj$base)
  ret$add("  %s *%s = NULL;", obj$type_pars, obj$name_pars)
  ret$add("  if (TYPEOF(%s_ptr) != EXTPTRSXP) {", obj$base)
  ret$add('    Rf_error("Expected an external pointer");')
  ret$add("  }")
  ret$add("  %s = (%s*) R_ExternalPtrAddr(%s_ptr);",
          obj$name_pars, obj$type_pars, obj$base)
  ret$add("  if (!%s && closed_error) {", obj$name_pars)
  ret$add('    Rf_error("Pointer has been invalidated");')
  ret$add("  }")
  ret$add("  return %s;", obj$name_pars)
  ret$add("}")
  ret$get()
}

odin_generate_deriv_r <- function(obj) {
  ret <- collector()
  ret$add("SEXP r_%s_deriv(SEXP %s_ptr, SEXP %s, SEXP %s) {",
          obj$base, obj$base, TIME, STATE)
  ret$add("  SEXP %s = PROTECT(allocVector(REALSXP, LENGTH(%s)));",
          DSTATEDT, STATE)
  ret$add("  // NOTE: this assigns to the deSolve-required global variable")
  ret$add("  %s *%s = %s_get_pointer(%s_ptr, 1);",
          obj$type_pars, obj$name_pars, obj$base, obj$base)

  if (is.null(obj$output)) {
    ret$add("  double *%s = NULL;", OUTPUT)
    np <- 1L
  } else {
    ret$add("  SEXP %s_ptr = PROTECT(allocVector(REALSXP, %s));",
            OUTPUT, obj$output_size)
    ret$add('  setAttrib(%s, install("%s"), %s_ptr);', DSTATEDT, OUTPUT, OUTPUT)
    ret$add("  double *%s = REAL(%s_ptr);", OUTPUT, OUTPUT)
    np <- 2L
  }

  ret$add("  %s_deriv(%s, REAL(%s)[0], REAL(%s), REAL(%s), %s);",
          obj$base, obj$name_pars, TIME, STATE, DSTATEDT, OUTPUT)
  ret$add("  UNPROTECT(%d);", np)
  ret$add("  return %s;", DSTATEDT)
  ret$add("}")
  ret$get()
}

odin_generate_desolve <- function(obj) {
  ret <- collector()
  ret$add("// deSolve interface")
  ret$add("void %s_ds_initmod(void(* odeparms) (int *, double *)) {",
          obj$base)
  ## TODO: this might change to something that uses the static trick
  ## here.
  ret$add('  DL_FUNC get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");')
  ret$add("  %s = %s_get_pointer(get_deSolve_gparms(), 1);",
          obj$name_pars, obj$base)
  ret$add("}")
  ret$add("void %s_ds_derivs(int *neq, double *%s, double *%s,",
          obj$base, TIME, STATE)
  ret$add("%sdouble *%s, double *%s, int *np) {",
          strrep(nchar(obj$base) + 15L), DSTATEDT, OUTPUT)
  ret$add("  %s_deriv(%s, *%s, %s, %s, %s);",
          obj$base, obj$name_pars, TIME, STATE, DSTATEDT, OUTPUT)
  ret$add("}")
  ret$get()
}

## Read a bunch of library functions.  The format here is important.
read_library <- function() {
  d <- readLines(system.file("library.c", package="odin"))
  re <- "^[[:alnum:]]+ ([[:alnum:]_]+)(.+) \\{$"
  i <- grep(re, d)
  j <- grep("^}$", d)
  stopifnot(length(i) == length(j))

  name <- sub(re, "\\1", d[i])
  decl <- setNames(sub(" \\{$", ";", d[i]), name)
  defn <- setNames(vcapply(seq_along(i), function(k)
    paste(d[i[[k]]:j[[k]]], collapse="\n")), name)
  list(declarations=decl, definitions=defn)
}

array_dim_name <- function(name, use=TRUE) {
  if (grepl("^initial_", name)) {
    name_dim <- sub("^initial_", "dim_", name)
  } else if (grepl("^delay_", name)) {
    if (use || grepl("_idx$", name)) {
      name_dim <- sprintf("dim_%s", sub("_[a-z]+$", "", name))
    } else {
      name_dim <- NULL
    }
  } else {
    name_dim <- sprintf("dim_%s", name)
  }
  name_dim
}
