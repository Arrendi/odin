% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interface.R
\name{odin}
\alias{odin}
\alias{odin_}
\title{Create an odin model}
\usage{
odin(x, dest = tempdir(), build = TRUE, load = TRUE, verbose = TRUE)

odin_(x, dest = ".", build = TRUE, load = TRUE, verbose = TRUE)
}
\arguments{
\item{x}{Either the name of a file to read, a text string (if
length is greater than 1 elements will be joined with newlines)
or an expression.}

\item{dest}{Destination \emph{directory} for generated files.  The
default is the temporary directory, but \code{"."} is
another useful value.}

\item{build}{Logical scalar indicating if we should build the
model (i.e. compile the dll).}

\item{load}{Logical scalar indicating if the dll should be loaded
and an \code{ode_generator} object returned.  Only used if
\code{build} is \code{TRUE}.}

\item{verbose}{Logical scalar indicating if the compilation should
be verbose.  In future versions this may also make the
parse/generate step be verbose too.}
}
\value{
If \code{load} is \code{TRUE}, an \code{ode_generator}
  object, otherwise the filename of the generated C file.
}
\description{
Create an odin model from a file, text string(s) or expression.
The \code{odin_} version is a "standard evaluation" escape hatch.
}
\section{Warning}{


Be careful with repeated use of \code{odin} on the same code; if
you have any models existing and not garbage collected then when
the shared library is reloaded this will crash R when the object
goes out of scope and is later garbage collected.  I'll tighten
this up in future versions, but for now this is an issue.
}

\section{Delay equations with dde}{


When generating a model one must chose between using the
\code{dde} package to solve the system or the default
\code{deSolve}.  Future versions may allow this to switch when
using \code{run}, but for now this requires tweaking the generated
code to a point where one must decide at generation.  \code{dde}
implements only the Dormand-Prince 5th order dense output solver,
with a delay equation solver that may perform better than the
solvers in deSolve.  For non-delay equations, \code{deSolve} is
very likely to outperform the simple solver implemented.
}
\examples{
if (can_compile()) { # only run this if a system is set up to compile

## Compile the model; exp_decay here is an R6ClassGenerator and will
## generate instances of a model of exponential decay:
exp_decay <- odin::odin({
  deriv(y) <- -0.5 * y
  initial(y) <- 1
})

## Generate an instance; there are no parameters here so all instances
## are the same and this looks a bit pointless.  But this step is
## required because in general you don't want to have to compile the
## model every time it is used (so the generator will go in a
## package).
mod <- exp_decay()

## Run the model for a series of times from 0 to 10:
t <- seq(0, 10, length.out=101)
y <- mod$run(t)
plot(y, xlab="Time", ylab="y", main="", las=1)

}

## If you want to see the underlying C code, pass build=FALSE:
## (Note: this step does not require a working C compiler)
path <- odin::odin({
  deriv(y) <- -0.5 * y
  initial(y) <- 1
}, build=FALSE)

## Lots of code:
cat(paste0(readLines(path), "\\n"))
}
\author{
Rich FitzJohn
}

