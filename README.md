# odin

[![Project Status: Concept - Minimal or no implementation has been done yet.](http://www.repostatus.org/badges/latest/concept.svg)](http://www.repostatus.org/#concept)

![](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9f/Odin_%28Manual_of_Mythology%29.jpg/250px-Odin_%28Manual_of_Mythology%29.jpg)

**Warning: This project is in the early scoping stages; do not use for anything other than amusement/frustration purposes**

# Scope

A declarative way of running ODEs at native (C) speed in R.  Implements a domain specific language based on a subset of R to a set of differential equations suitable for solving with deSolve.

For example (and because *all* ODE software seems to like using it), here is the standard Lorenz attractor model in `odin` (actual file [here](tests/testthat/examples/lorenz_odin.R)).

```r
## Derivatives
deriv(y1) <- sigma * (y2 - y1)
deriv(y2) <- R * y1 - y2 - y1 * y3
deriv(y3) <- -b * y3 + y1 * y2

## Initial conditions
initial(y1) <- 10.0
initial(y2) <- 1.0
initial(y3) <- 1.0

## parameters
sigma <- 10.0
R     <- 28.0
b     <-  8.0 / 3.0
```

Running this through odin generates C code that can be compiled and loaded into R (the actual functions for doing that are still under flux).  For more complicated examples, check out an [age structured SIR model](tests/testthat/examples/array_odin.R).

# Notes on development

The idea is to be able to convert a set of highly restricted R code into a set of differential equations that can be compiled into C.  This will simplify the deSolve/R/C use-case and reduce the amount of boilerplate and development time.  The generated code, while not being designed to be edited, should be fairly simple to understand.  In future versions, R interfaces might be generated to make it easy to test the model.

Berkeley Madonna is the inspiration for the DSL that we'll build up.

* declarative interface
* array equation syntax
* delay equations

`odin` inspects the equations and works out which bits are run at model creation (constant for all models), initialisation (depending on initial time, conditions or on user-supplied parameters), or in derivative calculations (depending on the ODE variables or time).

The nice thing about code generation approaches is that they never get bored.  So if the generated code has lots of boring repetitive bits, they're at least likely to be correct (compared with implementing yourself).

# Special functions that will be allowed

* `length` and `dim`; for getting matrix dimensions of 1 and multidimensional arrays (respectively)
* a reasonably large set of mathematical constructs, including all basic R operators (not all implemented yet)
* something to declare arbitrary functions available to R (for initialisation only and not for the derivatives calculations) as it's ok to wear that cost once.
* something to declare and use arbitrary pure C functions.

# Initial conditions

In contrast to deSolve, models produced by `odin` will compute their own initial conditions.  This is because it is usually convenient to specify initial conditions in terms of parameters shared with the dynamic parts of the model.  Support for user-specified (i.e. non-compiled) parameters is available via the function `user`, which currently only accepts scalars.

# deSolve compatibility

This package is designed to solve large sets of differential equations where it is not necessarily feasible or convenient to manually construct the state vector.  As such, an additional "initialisation" step will be needed in addition to the deSolve calls.  In a returned model, the initialisation function *must* be called before integration.

An alternative approach would be to include the initial state in the "parameters" object.  That would probably do an OK job of initialising while staying a bit closer to the deSolve interface; it also guarantees that the delay functions will always get access to the values.

# Development plan

* Scope the core features we want to support:
  - R'ish DSL
  - delay differential equations
  - generation of initial conditions from parameters
  - compilation to C code
  - array indexing for equations
* Construct a roughly working version with a bunch of test cases
  - implemted in BM, and output saved to CSV files
  - implemented naively in R for deSolve; speed is not an issue here
  - implemented with our DSL
  for each of the test cases we'd check that the generated model compiles and gives the same output.  The BM to R checks will be done but really simple.

# Limitations

Writing this has given me a much greater appreciation of the difficulties of writing compiler error messages.

This does not attempt to translate R into C (though very simple expressions are handled) but only a small subset that follows the sterotyped way that R+C ODE models tend to be written.  It tries to do things like minimise the number of memory allocations while preventing leaks.

The code generated by `odin` may not make sense, may not compile and may crash R.  Over time I will try to catch more of these during the parse step, but there's a lot of checking to do.  For now, be warned.

Because this is very new, it is quite possible that the code that is generated will not correspond to your model.  You are advised to read the generated code and to test your model thoroughly before assuming it is doing the right thing.  The generated code is designed to be straightforward to read, leaving any really funky optimisation to the compiler.

Because this relies on code generation, and the approach is partly textual, some oddities will appear in the generated code (things like `n + 0`).  Over time I'll remove the most egregious of these.  It's probable that there will be some unused variables, and unused elements in the parameters struct.
