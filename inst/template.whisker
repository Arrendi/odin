// This is automatically generated by odin; do not edit by hand as
// changes will be lost.
#include <R.h>
#include <Rinternals.h>
#include <R_ext/Rdynload.h>

typedef struct {{{pars_type}}} {
{{{struct}}}
} {{{pars_type}}};
static {{{pars_type}}} *{{{pars_object}}};

{{{pars_type}}}* {{{prefix}}}_get_pointer(SEXP extPtr, int closed_error);
static void {{{prefix}}}_finalise(SEXP extPtr);
void {{{prefix}}}_create({{{pars_type}}} *{{{pars_object}}});
SEXP {{{prefix}}}_initialise({{{pars_type}}} *{{{pars_object}}}, double t, SEXP given);
void {{{prefix}}}_deriv({{{pars_type}}} *{{{pars_object}}}, double t, double *{{{state}}}, double *{{{dstatedt}}});
void {{{prefix}}}_free({{{pars_type}}} *{{{pars_object}}});
SEXP {{{prefix}}}_order({{{pars_type}}} *{{{pars_object}}});
SEXP {{{prefix}}}_contents({{{pars_type}}} *{{{pars_object}}});

double {{{prefix}}}_get_user_double(SEXP given, const char *name, double default_value);
int {{{prefix}}}_get_user_int(SEXP given, const char *name, int default_value);
void {{{prefix}}}_get_user_vec(SEXP given, const char *name, int len, double *ret);
SEXP get_list_element(SEXP list, const char *name);
double odin_sum(double *x, int len);

// R interface
SEXP r_{{{prefix}}}_create() {
  {{{pars_type}}} *p = ({{{pars_type}}}*) R_Calloc(1, {{{pars_type}}});
  {{{prefix}}}_create(p);
  SEXP extPtr = PROTECT(R_MakeExternalPtr(p, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(extPtr, {{{prefix}}}_finalise);
  UNPROTECT(1);
  return extPtr;
}

SEXP r_{{{prefix}}}_initialise(SEXP extPtr, SEXP t, SEXP given) {
  return {{{prefix}}}_initialise({{{prefix}}}_get_pointer(extPtr, 1), REAL(t)[0], given);
}

SEXP r_{{{prefix}}}_deriv(SEXP extPtr, SEXP y, SEXP t) {
  SEXP dydt = PROTECT(allocVector(REALSXP, LENGTH(y)));
  {{{pars_type}}} *p = {{{prefix}}}_get_pointer(extPtr, 1);
  {{{prefix}}}_deriv(p, REAL(t)[0], REAL(y), REAL(dydt));
  UNPROTECT(1);
  return dydt;
}

SEXP r_{{{prefix}}}_order(SEXP extPtr) {
  return {{{prefix}}}_order({{{prefix}}}_get_pointer(extPtr, 1));
}

SEXP r_{{{prefix}}}_contents(SEXP extPtr) {
  return {{{prefix}}}_contents({{{prefix}}}_get_pointer(extPtr, 1));
}

// deSolve interface
void {{{prefix}}}_ds_initmod(void(* odeparms) (int *, double *)) {
  DL_FUNC get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");
  {{{pars_object}}} = {{{prefix}}}_get_pointer(get_deSolve_gparms(), 1);
}

void {{{prefix}}}_ds_derivs(int *neq, double *t, double *{{{state}}},
                    double *{{{dstatedt}}}, double *yout, int *np) {
  {{{prefix}}}_deriv({{{pars_object}}}, *t, {{{state}}}, {{{dstatedt}}});
}

// Pointer utilities
{{{pars_type}}}* {{{prefix}}}_get_pointer(SEXP extPtr, int closed_error) {
  {{{pars_type}}} *p = NULL;
  if (TYPEOF(extPtr) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  p = ({{{pars_type}}}*) R_ExternalPtrAddr(extPtr);
  if (!p && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return p;
}

void {{{prefix}}}_finalise(SEXP extPtr) {
  {{{pars_type}}} *p = {{{prefix}}}_get_pointer(extPtr, 0);
  if (p) {
    {{{prefix}}}_free(p);
    Free(p);
  }
}

// Generated code
void {{{prefix}}}_create({{{pars_type}}} *{{{pars_object}}}) {
{{{create}}}
}

SEXP {{{prefix}}}_initialise({{{pars_type}}} *{{{pars_object}}}, double t, SEXP given) {
{{{initialise}}}
{{{copy}}}
}

void {{{prefix}}}_deriv({{{pars_type}}} *{{{pars_object}}}, double {{{time}}}, double *{{{state}}}, double *{{{dstatedt}}}) {
{{{deriv}}}
}

void {{{prefix}}}_free({{{pars_type}}} *{{{pars_object}}}) {
{{{free}}}
}

SEXP {{{prefix}}}_order({{{pars_type}}} *{{{pars_object}}}) {
{{{order}}}
}

SEXP {{{prefix}}}_contents({{{pars_type}}} *{{{pars_object}}}) {
{{{contents}}}
}

// Utilities for dealing with user-supplied values
// TODO: These should all go through coerceVector with the appropriate PROTECT/UNPROTECT pair
double {{{prefix}}}_get_user_double(SEXP given, const char *name, double default_value) {
  double ret = default_value;
  SEXP el = get_list_element(given, name);
  if (el != R_NilValue) {
    ret = REAL(el)[0];
  }
  if (ISNA(ret)) {
    Rf_error("Expected value for %s", name);
  }
  return ret;
}

int {{{prefix}}}_get_user_int(SEXP given, const char *name, int default_value) {
  int ret = default_value;
  SEXP el = get_list_element(given, name);
  if (el != R_NilValue) {
    ret = INTEGER(el)[0];
  }
  if (ISNA(ret)) {
    Rf_error("Expected value for %s", name);
  }
  return ret;
}

void {{{prefix}}}_get_user_vec(SEXP given, const char *name, int len, double *ret) {
  SEXP el = get_list_element(given, name);
  if (el != R_NilValue) {
    if (length(el) != len) {
      Rf_error("Incorrect length for %s; expected %d received %d",
               name, len, length(el));
    }
    memcpy(ret, REAL(el), len * sizeof(double));
  }
  // TODO: how to tell if this was not recieved?
}

SEXP get_list_element(SEXP list, const char *name) {
  SEXP ret = R_NilValue, names = getAttrib(list, R_NamesSymbol);
  for (int i = 0; i < length(list); ++i) {
    if(strcmp(CHAR(STRING_ELT(names, i)), name) == 0) {
      ret = VECTOR_ELT(list, i);
      break;
    }
  }
  return ret;
}

// Utilities
double odin_sum(double *x, int len) {
  double tot = 0.0;
  for (int i = 0; i < len; ++i) {
    tot += x[i];
  }
  return tot;
}
