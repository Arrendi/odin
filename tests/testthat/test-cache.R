context("model cache")


test_that("model_cache", {
  obj <- R6_model_cache$new()
  expect_is(obj, "model_cache")
  expect_equal(obj$list(), character())
  expect_null(obj$get("a"))
  x <- runif(10)
  obj$put("a", x)
  expect_equal(obj$list(), "a")
  expect_equal(obj$get("a"), x)

  ## overflow the ring
  obj$resize(4)
  for (x in letters[2:4]) {
    obj$put(x, x)
  }
  expect_equal(obj$list(), c("d", "c", "b", "a"))

  obj$put("e", "e")
  expect_equal(obj$list(), c("e", "d", "c", "b"))

  obj$put("c", "c")
  expect_equal(obj$list(), c("c", "e", "d", "b"))

  obj$clear()
  expect_equal(obj$list(), character())
  expect_null(obj$get("a"))
})


test_that("hash model", {
  code <- c("deriv(y) <- 0.5",
            "initial(y) <- 1")
  expect_equal(hash_model(odin_preprocess(code)),
               hash_model(odin_preprocess(code)))
  expect_error(hash_model(code),
               "Expected preprocessed model")
})


test_that("invalidate cache", {
  model_cache_clear()
  code <- c("deriv(y) <- 0.5",
            "initial(y) <- 1")

  gen <- odin(code, verbose = TEST_VERBOSE)
  expect_equal(model_cache_list(), hash_model(odin_preprocess(code)))
  expect_message(odin(code, verbose = TRUE),
                 "Using cached model")

  dat <- model_cache_get(hash_model(odin_preprocess(code)), FALSE)

  expect_true(is_directory(dat$dll$path))
  expect_true(file.exists(dat$dll$dll))

  model_cache_clear()
  expect_message(
    gen <- odin(code, dest = dat$dll$path, verbose = TRUE),
    "Using previously compiled shared library")
})


test_that("includes", {
  fns <- readLines("user_fns.c")
  fns2 <- gsub("t1", "t2", fns)
  user <- basename(tempfile("odin_", ".", ".c"))
  writeLines(fns, user)
  on.exit(file.remove(user))
  expr <- substitute_(quote({
    config(include) <- user_fns
    z <- squarepulse(t, 1, 2)
    output(z) <- z
    deriv(y) <- z
    initial(y) <- 0
  }), list(user_fns = user))

  gen <- odin(expr, verbose = TEST_VERBOSE)
  expect_message(odin(expr, verbose = TRUE), "Using cached model")

  writeLines(fns2, user)
  expect_message(capture.output(gen <- odin(expr, verbose = TRUE)),
                 "Compiling shared library")
  expect_message(gen <- odin(expr, verbose = TRUE),
                 "Using cached model")
})


test_that("filename", {
  model_cache_clear()
  code1 <- c("deriv(y)<- 0.5",
            "initial(y)<- 1")
  code2 <- c("# some comment", code1)

  tmp <- tempfile(fileext = ".R")
  writeLines(code1, tmp)

  gen <- odin(tmp, verbose = TEST_VERBOSE)
  h1 <- hash_model(odin_preprocess(tmp))
  expect_equal(model_cache_list(), h1)
  expect_message(odin(tmp, verbose = TRUE),
                 "Using cached model")

  dat <- model_cache_get(h1, FALSE)

  expect_true(is_directory(dat$dll$path))
  expect_true(file.exists(dat$dll$dll))

  writeLines(code2, tmp)
  h2 <- hash_model(odin_preprocess(tmp))
  expect_message(capture.output(odin(tmp, verbose = TRUE)),
                 "Compiling shared library")

  expect_equal(sort(model_cache_list()),
               sort(c(h1, h2)))
})


test_that("avoid overwriting non-odin .c code", {
  dest <- tempfile()

  model_cache_clear()
  code <- c("deriv(y) <- 0.5",
            "initial(y) <- 1")
  tmp <- tempfile(fileext = ".R")
  writeLines(code, tmp)

  gen <- odin(tmp, dest = dest, verbose = TEST_VERBOSE)
  h <- hash_model(odin_preprocess(tmp))
  dat <- model_cache_get(h, FALSE)
  model_cache_clear()
  rm(gen)
  gc()

  src <- readLines(dat$dll$source)
  expect_equal(src[[1L]], "// This file was automatically generated by odin.")
  file.remove(dat$dll$dll)

  ## Edit the file a little and we get an error:
  writeLines(src[-1], dat$dll$source)
  expect_error(odin(tmp, dest = dest),
               "Refusing to overwrite non-odin file")
})


unload_dlls()
